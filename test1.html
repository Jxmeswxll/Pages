<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>3D PC Customizer Pro</title>
    <style>
      /* ====== Base / Tokens ====== */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      :root {
        --bg1: #0b1020;
        --bg2: #131a33;
        --panel: rgba(255, 255, 255, 0.06);
        --panel-2: rgba(255, 255, 255, 0.04);
        --border: rgba(255, 255, 255, 0.12);
        --text: #e8ecff;
        --muted: #a6b0d8;
        --accent: #6d8cff;
        --accent-2: #a06cd5;
        --success: #2ecc71;
        --danger: #ff5b5b;
        --shadow: 0 24px 60px rgba(0, 0, 0, 0.5);
        --radius: 16px;
      }
      html,
      body {
        height: 100%;
      }
      body {
        font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        background: radial-gradient(
            1000px 700px at 12% 8%,
            #1a2356 0%,
            #0b1020 50%
          ),
          linear-gradient(135deg, #0b1020 0%, #14112e 100%);
        color: var(--text);
        display: grid;
        place-items: center;
        padding: 20px;
      }

      /* ====== Buttons / Inputs ====== */
      .btn {
        border: 1px solid var(--border);
        background: var(--panel);
        color: var(--text);
        padding: 12px 14px;
        border-radius: 12px;
        font-weight: 700;
        font-size: 14px;
        cursor: pointer;
        transition: filter 0.2s, transform 0.12s;
        min-height: 44px;
      }
      .btn:hover:not(:disabled) {
        filter: brightness(1.08);
      }
      .btn:active:not(:disabled) {
        transform: translateY(1px);
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .btn-primary {
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        border-color: transparent;
        color: #fff;
        box-shadow: 0 4px 12px rgba(109, 140, 255, 0.3);
      }
      .btn-success {
        background: linear-gradient(135deg, #2ecc71, #27ae60);
        border-color: transparent;
        color: #fff;
        box-shadow: 0 4px 12px rgba(46, 204, 113, 0.3);
      }
      .btn-danger {
        background: rgba(255, 91, 91, 0.12);
        color: #ffb3b3;
        border-color: rgba(255, 91, 91, 0.25);
      }
      .segmented {
        display: grid;
        grid-auto-flow: column;
        gap: 8px;
      }
      .seg-btn {
        border: 1px solid var(--border);
        background: var(--panel);
        padding: 10px 12px;
        border-radius: 12px;
        font-weight: 700;
        font-size: 13px;
        cursor: pointer;
        transition: filter 0.2s, transform 0.12s, background 0.2s;
        min-height: 44px;
      }
      .seg-btn.active {
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        color: #fff;
        border-color: transparent;
        box-shadow: 0 6px 20px rgba(109, 140, 255, 0.25);
      }

      /* ====== Modal / Layout ====== */
      .open-btn {
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        color: white;
        border: none;
        padding: 16px 28px;
        font-size: 16px;
        font-weight: 700;
        border-radius: var(--radius);
        cursor: pointer;
        box-shadow: var(--shadow);
        transition: transform 0.2s, filter 0.2s;
        -webkit-tap-highlight-color: transparent;
      }
      .open-btn:hover {
        transform: translateY(-2px);
        filter: brightness(1.05);
      }
      .modal {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(10, 12, 24, 0.6);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.25s ease;
      }
      .modal.active {
        display: grid;
        place-items: center;
        opacity: 1;
      }
      .modal-content {
        width: min(100%, 1000px);
        height: min(92vh, 840px);
        background: linear-gradient(
          180deg,
          rgba(22, 28, 56, 0.9),
          rgba(14, 18, 38, 0.9)
        );
        border: 1px solid var(--border);
        border-radius: 20px;
        overflow: hidden;
        display: grid;
        grid-template-rows: auto 1fr auto;
        box-shadow: var(--shadow);
        transform: translateY(10px);
        animation: pop 0.25s ease forwards;
      }
      @keyframes pop {
        to {
          transform: translateY(0);
        }
      }
      .modal-header {
        display: grid;
        grid-template-columns: 1fr auto auto;
        align-items: center;
        gap: 12px;
        padding: 12px 16px;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(
          180deg,
          rgba(19, 25, 50, 0.7),
          rgba(19, 25, 50, 0.4)
        );
      }
      .title {
        font-weight: 800;
        letter-spacing: 0.3px;
      }
      .close-btn {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid var(--border);
        width: 36px;
        height: 36px;
        border-radius: 10px;
        display: grid;
        place-items: center;
        font-size: 18px;
        cursor: pointer;
        transition: filter 0.2s;
      }

      #canvas-container {
        position: relative;
        background: linear-gradient(135deg, #0f1330, #141b3d, #121633);
        border-top: 1px solid var(--border);
        border-bottom: 1px solid var(--border);
        display: grid;
        grid-template-columns: 1fr;
        gap: 1px;
        background: var(--border);
      }
      
      #three-view {
        position: relative;
        background: linear-gradient(135deg, #0f1330, #141b3d);
        min-height: 300px;
      }
      
      #editor-view {
        position: relative;
        display: none;
        place-items: center;
        background: #1a1a2e;
        padding: 20px;
        min-height: 300px;
      }
      
      #editor-view.active {
        display: grid;
      }
      
      .loader {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        color: white;
        font-size: 16px;
        gap: 10px;
        pointer-events: none;
        z-index: 2;
      }
      .spinner {
        border: 3px solid rgba(255, 255, 255, 0.12);
        border-top: 3px solid white;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        animation: spin 1s linear infinite;
        margin: 0 auto 6px;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .controls {
        padding: 12px;
        display: grid;
        gap: 12px;
        border-top: 1px solid var(--border);
        background: var(--panel-2);
        max-height: 280px;
        overflow-y: auto;
      }
      .section {
        display: grid;
        gap: 8px;
        padding: 12px;
        border: 1px solid var(--border);
        border-radius: 14px;
        background: var(--panel);
      }
      .label {
        color: var(--muted);
        font-size: 12px;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: 0.6px;
      }

      /* Action row */
      .action-row {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
        align-items: center;
      }
      .hint {
        color: var(--muted);
        font-size: 12px;
        text-align: center;
        line-height: 1.4;
      }

      /* 2D Editor Canvas */
      #panel-editor {
        max-width: 100%;
        max-height: 100%;
        border: 2px solid var(--border);
        border-radius: 8px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        cursor: grab;
        background: #1a1a2e;
      }
      #panel-editor:active {
        cursor: grabbing;
      }
      
      #editor-info {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(20, 26, 52, 0.95);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px 16px;
        color: var(--text);
        font-size: 13px;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        z-index: 5;
      }
      
      #editor-info h3 {
        margin: 0 0 4px 0;
        font-size: 14px;
        color: var(--accent);
        font-weight: 800;
      }
      
      #editor-instructions {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(20, 26, 52, 0.95);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px 16px;
        color: var(--text);
        font-size: 12px;
        line-height: 1.6;
        max-width: 250px;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        z-index: 5;
      }
      
      #editor-instructions h4 {
        margin: 0 0 6px 0;
        font-size: 13px;
        color: var(--accent);
        font-weight: 800;
      }
      
      #editor-instructions ul {
        margin: 0;
        padding-left: 18px;
      }
      
      #editor-instructions li {
        margin: 3px 0;
        color: var(--muted);
      }

      /* Floating Toolbar */
      #panel-editor-toolbar {
        position: fixed;
        left: 50%;
        bottom: 32px;
        transform: translateX(-50%);
        z-index: 100;
        display: none;
        gap: 12px;
        background: rgba(20, 26, 52, 0.98);
        padding: 16px 20px;
        border-radius: 20px;
        border: 1px solid var(--border);
        box-shadow: 0 12px 48px rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(20px);
        animation: slideUp 0.3s ease;
      }

      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }

      .toolbar-group {
        display: flex;
        gap: 8px;
        padding: 0 8px;
        border-right: 1px solid var(--border);
      }

      .toolbar-group:last-child {
        border-right: none;
        padding-right: 0;
      }

      .toolbar-group:first-child {
        padding-left: 0;
      }

      .tool-btn {
        min-width: 44px;
        min-height: 44px;
        display: grid;
        place-items: center;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 18px;
        color: var(--text);
      }

      .tool-btn:hover {
        background: var(--panel-2);
        border-color: var(--accent);
        transform: translateY(-2px);
      }

      .tool-btn.active {
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        border-color: transparent;
        color: white;
      }

      /* View mode toggle */
      .view-mode-toggle {
        position: absolute;
        top: 12px;
        left: 12px;
        z-index: 5;
        display: flex;
        gap: 6px;
        background: rgba(20, 26, 52, 0.95);
        padding: 6px;
        border-radius: 12px;
        border: 1px solid var(--border);
      }

      .view-mode-btn {
        padding: 8px 12px;
        background: transparent;
        border: 1px solid transparent;
        color: var(--muted);
        border-radius: 8px;
        font-size: 12px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
        min-height: 36px;
      }

      .view-mode-btn.active {
        background: var(--panel);
        border-color: var(--accent);
        color: var(--accent);
      }

      /* Toast */
      .toast {
        position: absolute;
        left: 50%;
        top: 16px;
        transform: translateX(-50%);
        background: rgba(20, 26, 52, 0.95);
        border: 1px solid var(--border);
        color: var(--text);
        padding: 12px 16px;
        border-radius: 12px;
        font-size: 13px;
        display: none;
        gap: 10px;
        align-items: center;
        z-index: 8;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        animation: slideDown 0.3s ease;
      }
      
      @keyframes slideDown {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }

      /* Upload loading overlay */
      .upload-loading {
        position: absolute;
        inset: 0;
        background: rgba(5, 8, 18, 0.8);
        backdrop-filter: blur(4px);
        z-index: 10;
        display: none;
        place-items: center;
      }
      
      .upload-loading.active {
        display: grid;
      }

      /* Template Gallery */
      .template-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 10px;
      }

      .template-item {
        aspect-ratio: 1;
        border-radius: 12px;
        overflow: hidden;
        cursor: pointer;
        border: 2px solid var(--border);
        transition: all 0.2s;
        position: relative;
      }

      .template-item:hover {
        border-color: var(--accent);
        transform: translateY(-2px);
      }

      .template-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .template-name {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(transparent, rgba(0,0,0,0.8));
        padding: 6px;
        font-size: 10px;
        font-weight: 700;
        text-align: center;
        color: white;
      }

      /* Tutorial styles */
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
      }
      
      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }

      .tutorial-spotlight {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        z-index: 9998;
        pointer-events: none;
      }

      .tutorial-highlight {
        position: fixed;
        border: 3px solid var(--accent);
        border-radius: 16px;
        z-index: 9999;
        box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.8), 0 0 40px var(--accent);
        animation: pulse 2s infinite;
        pointer-events: none;
      }

      .tutorial-card {
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(180deg, rgba(22, 28, 56, 0.98), rgba(14, 18, 38, 0.98));
        border: 2px solid var(--accent);
        border-radius: 20px;
        padding: 24px;
        max-width: 400px;
        z-index: 10000;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        animation: slideIn 0.3s ease;
      }

      /* Mobile FAB */
      .mobile-fab-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        left: 20px;
        z-index: 200;
        display: none;
        gap: 10px;
        justify-content: center;
      }

      .mobile-fab {
        flex: 1;
        max-width: 150px;
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        color: white;
        border: none;
        padding: 16px 20px;
        border-radius: 50px;
        font-weight: 800;
        font-size: 15px;
        box-shadow: 0 8px 24px rgba(109, 140, 255, 0.5);
        cursor: pointer;
        transition: transform 0.2s;
      }

      .mobile-fab:active {
        transform: scale(0.95);
      }

      /* Focus */
      .seg-btn:focus-visible,
      .btn:focus-visible,
      .close-btn:focus-visible,
      .open-btn:focus-visible,
      .tool-btn:focus-visible,
      .view-mode-btn:focus-visible {
        outline: 3px solid rgba(109, 140, 255, 0.6);
        outline-offset: 2px;
        box-shadow: 0 0 0 3px rgba(109, 140, 255, 0.25);
      }

      @media (max-width: 1024px) {
        #canvas-container.split-mode {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 768px) {
        .modal-content {
          width: 100vw;
          height: 100vh;
          border-radius: 0;
        }

        .controls {
          max-height: 40vh;
          border-radius: 24px 24px 0 0;
          padding: 16px 12px 100px 12px;
        }

        .controls::before {
          content: '';
          display: block;
          width: 40px;
          height: 4px;
          background: var(--border);
          border-radius: 2px;
          margin: -6px auto 12px;
        }

        body:has(.modal.active) .mobile-fab-container {
          display: flex;
        }

        #editor-instructions {
          font-size: 11px;
          padding: 10px 12px;
          max-width: 200px;
        }

        #panel-editor-toolbar {
          flex-wrap: wrap;
          width: calc(100vw - 40px);
          max-width: 500px;
        }

        .toolbar-group {
          border-right: none;
          border-bottom: 1px solid var(--border);
          padding-bottom: 8px;
          flex-wrap: wrap;
          width: 100%;
          justify-content: center;
        }

        .toolbar-group:last-child {
          border-bottom: none;
          padding-bottom: 0;
        }

        .view-mode-toggle {
          flex-direction: column;
          width: auto;
        }
      }

      @media (max-width: 680px) {
        .modal-content {
          width: calc(100dvw - 24px);
          height: calc(100dvh - 24px);
        }
      }
    </style>
  </head>
  <body>
    <button class="open-btn" onclick="openModal()">Start customizing</button>

    <div id="modal" class="modal" role="dialog" aria-modal="true">
      <div class="modal-content">
        <div class="modal-header">
          <div class="title">3D PC Customizer Pro</div>
          
          <div style="display: flex; gap: 8px; align-items: center;">
            <button 
              id="undo-btn" 
              class="btn" 
              onclick="undoLast()" 
              disabled
              style="padding: 8px 12px; font-size: 13px;"
              title="Undo last change (Ctrl+Z)">
              ‚Ü∂ Undo
            </button>
            <button 
              class="btn btn-success" 
              onclick="exportAll()" 
              style="padding: 8px 14px; font-size: 13px;">
              üíæ Export All
            </button>
          </div>
          
          <button class="close-btn" onclick="closeModal()" aria-label="Close">
            √ó
          </button>
        </div>

        <div id="canvas-container" aria-label="3D preview">
          <div class="view-mode-toggle">
            <button class="view-mode-btn active" onclick="setViewMode('3d-only')">
              3D Only
            </button>
            <button class="view-mode-btn" onclick="setViewMode('split')">
              Split View
            </button>
            <button class="view-mode-btn" onclick="setViewMode('2d-only')">
              2D Only
            </button>
          </div>

          <div class="loader" id="loader">
            <div class="spinner"></div>
            <div>Loading 3D Model...</div>
          </div>
          
          <!-- Upload loading overlay -->
          <div class="upload-loading" id="upload-loading">
            <div>
              <div class="spinner"></div>
              <div style="color: white; margin-top: 12px;">Processing image...</div>
            </div>
          </div>

          <!-- 3D View -->
          <div id="three-view"></div>

          <!-- 2D Editor View -->
          <div id="editor-view">
            <canvas id="panel-editor"></canvas>
            
            <div id="editor-info">
              <h3 id="editor-panel-name">Front Panel</h3>
              <div id="editor-dimensions">1024 √ó 1024 px</div>
            </div>
            
            <div id="editor-instructions">
              <h4>üìê Controls</h4>
              <ul>
                <li><strong>Drag</strong> logo to move</li>
                <li><strong>Scroll</strong> to scale</li>
                <li><strong>R</strong> to rotate</li>
                <li><strong>C</strong> to center</li>
                <li><strong>Arrows</strong> for precision</li>
              </ul>
            </div>
          </div>

          <!-- Toast -->
          <div id="toast" class="toast" role="status" aria-live="polite">
            <span id="toast-text">Applied.</span>
          </div>
        </div>

        <!-- Floating Toolbar -->
        <div id="panel-editor-toolbar">
          <!-- Transform tools -->
          <div class="toolbar-group">
            <button class="tool-btn" onclick="resetLogoTransform()" title="Reset position">
              üéØ
            </button>
            <button class="tool-btn" onclick="centerLogo()" title="Center (C)">
              ‚äï
            </button>
            <button class="tool-btn" onclick="rotateLogo(-90)" title="Rotate left 90¬∞">
              ‚Ü∫
            </button>
            <button class="tool-btn" onclick="rotateLogo(90)" title="Rotate right 90¬∞">
              ‚Üª
            </button>
          </div>
          
          <!-- Scale -->
          <div class="toolbar-group">
            <button class="tool-btn" onclick="scaleLogo(0.9)" title="Shrink (-)">
              üîç‚àí
            </button>
            <button class="tool-btn" onclick="scaleLogo(1.1)" title="Grow (+)">
              üîç+
            </button>
          </div>
          
          <!-- Actions -->
          <div class="toolbar-group">
            <button class="btn btn-success" onclick="applyLogoToPanel()" style="padding: 10px 16px;">
              ‚úì Apply
            </button>
            <button class="btn btn-danger" onclick="cancelLogoEdit()" style="padding: 10px 16px;">
              ‚úï Cancel
            </button>
          </div>
        </div>

        <div class="controls">
          <!-- Template Gallery -->
          <div class="section">
            <div class="label">üé® Quick Start Templates</div>
            <div class="hint" style="margin-bottom: 8px;">
              Click to apply a pre-made design
            </div>
            
            <div class="template-grid" id="template-grid">
              <!-- Templates populated by JS -->
            </div>
          </div>

          <!-- 1) Side -->
          <div class="section">
            <div class="label">Choose a side</div>
            <div class="segmented" role="tablist" aria-label="PC sides">
              <button
                class="seg-btn active"
                onclick="selectSide('front', this)"
                aria-pressed="true"
              >
                Front
              </button>
              <button class="seg-btn" onclick="selectSide('left', this)">
                Left
              </button>
              <button class="seg-btn" onclick="selectSide('right', this)">
                Right
              </button>
              <button class="seg-btn" onclick="selectSide('back', this)">
                Back
              </button>
              <button class="seg-btn" onclick="selectSide('top', this)">Top</button>
              <button class="seg-btn" onclick="selectSide('bottom', this)">
                Bottom
              </button>
            </div>
          </div>

          <!-- 2) Mode -->
          <div class="section">
            <div class="label">Choose how to print</div>
            <div class="segmented" role="tablist" aria-label="Print mode">
              <button
                id="mode-full"
                class="seg-btn active"
                onclick="setPrintMode('full', this)"
                aria-pressed="true"
              >
                Full Panel
              </button>
              <button
                id="mode-logo"
                class="seg-btn"
                onclick="setPrintMode('logo', this)"
                aria-pressed="false"
              >
                Logo
              </button>
            </div>
            <div id="mode-hint" class="hint">
              Fill the entire panel with your image.
            </div>
          </div>

          <!-- 3) Action -->
          <div class="section">
            <div class="action-row">
              <button
                id="uploadBtn"
                class="btn btn-primary"
                onclick="triggerUpload()"
                style="width: 100%;"
              >
                üì§ Upload image for Front
              </button>

              <div class="hint" id="inline-hint">
                üí° Tip: Click a face in the 3D view to select it
              </div>
            </div>

            <!-- Apply to multiple sides -->
            <div style="display: flex; gap: 8px; margin-top: 8px;">
              <button class="btn" onclick="applyToAllSides()" style="flex: 1; font-size: 12px;">
                üìã Apply to All
              </button>
              <button class="btn" onclick="applyToGroup('vertical')" style="flex: 1; font-size: 12px;">
                ‚ÜïÔ∏è Vertical
              </button>
            </div>

            <!-- Actions -->
            <div style="display:flex; gap:8px; margin-top:4px">
              <button class="btn" onclick="resetSide()" style="flex: 1;">Reset this side</button>
              <button class="btn" onclick="resetAll()" style="flex: 1;">Reset all sides</button>
              <button class="btn btn-success" onclick="exportCurrentSide()" style="flex: 1;">üíæ Export</button>
            </div>
          </div>

          <input
            type="file"
            id="fileInput"
            accept="image/*,.svg"
            style="display: none"
            onchange="handleFileUpload(event)"
          />
        </div>
      </div>
    </div>

    <!-- Mobile FAB -->
    <div class="mobile-fab-container">
      <button class="mobile-fab" onclick="triggerUpload()">
        üì§ Upload
      </button>
      <button class="mobile-fab" onclick="exportCurrentSide()" style="background: linear-gradient(135deg, var(--success), #27ae60);">
        üíæ Export
      </button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // ====== Constants ======
      const TEXTURE_SIZE = 1024;
      const SNAP_THRESHOLD = 0.05;
      const MAX_UNDO = 10;
      const HANDLE_SIZE = 20; // For Canva-style handles
      
      // ====== 3D Core State ======
      let scene, camera, renderer, pcCase, pcGroup, hoverOutline;
      let raycaster = new THREE.Raycaster();
      let mouse = new THREE.Vector2();
      let isModalOpen = false;
      let currentSide = "front";
      let printMode = "full";
      let isEditingLogo = false;
      let viewMode = "3d-only";

      // Undo stack
      let undoStack = [];
      let saveTimeout;

      // 2D editor state - Canva-style
      let editorCanvas, editorCtx, editorImg = null;
      let editorTransform = { x: 0.5, y: 0.5, scale: 0.3, rot: 0 };
      let editorDragging = false;
      let editorRotating = false;
      let editorScaling = false;
      let editorScaleCorner = null;
      let editorLast = { x: 0, y: 0 };
      let editorImageNatural = { w: 0, h: 0 };
      let editorTouches = [];

      const sideTextures = {
        front: null,
        back: null,
        left: null,
        right: null,
        top: null,
        bottom: null,
      };

      const pcSizes = {
        mini: { width: 1.5, height: 2, depth: 1.5, name: "Mini ITX" },
        medium: { width: 2, height: 3, depth: 2, name: "Mid Tower" },
        large: { width: 2.5, height: 4, depth: 2.5, name: "Full Tower" },
      };
      let currentSize = "medium";

      // Tutorial
      let hasSeenTutorial = localStorage.getItem("pc-customizer-tutorial-seen") === "true";

      // Template Library
      const templateLibrary = [
        {
          id: "gradient-purple",
          name: "Purple Gradient",
          category: "solid",
          preview: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%236d28d9'/%3E%3Cstop offset='100%25' style='stop-color:%23a855f7'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23g)' width='100' height='100'/%3E%3C/svg%3E",
          generate: (canvas) => {
            const ctx = canvas.getContext("2d");
            const grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            grad.addColorStop(0, "#6d28d9");
            grad.addColorStop(1, "#a855f7");
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        },
        {
          id: "gradient-blue",
          name: "Ocean Blue",
          category: "solid",
          preview: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%230ea5e9'/%3E%3Cstop offset='100%25' style='stop-color:%232563eb'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23g)' width='100' height='100'/%3E%3C/svg%3E",
          generate: (canvas) => {
            const ctx = canvas.getContext("2d");
            const grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            grad.addColorStop(0, "#0ea5e9");
            grad.addColorStop(1, "#2563eb");
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        },
        {
          id: "gradient-red",
          name: "Fire Red",
          category: "solid",
          preview: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23dc2626'/%3E%3Cstop offset='100%25' style='stop-color:%23f97316'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23g)' width='100' height='100'/%3E%3C/svg%3E",
          generate: (canvas) => {
            const ctx = canvas.getContext("2d");
            const grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            grad.addColorStop(0, "#dc2626");
            grad.addColorStop(1, "#f97316");
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        },
        {
          id: "grid-pattern",
          name: "Tech Grid",
          category: "pattern",
          preview: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100'%3E%3Crect fill='%23111827' width='100' height='100'/%3E%3Cpath d='M0 25h100M0 50h100M0 75h100M25 0v100M50 0v100M75 0v100' stroke='%233b82f6' stroke-width='1' opacity='0.3'/%3E%3C/svg%3E",
          generate: (canvas) => {
            const ctx = canvas.getContext("2d");
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = "#111827";
            ctx.fillRect(0, 0, w, h);
            
            ctx.strokeStyle = "rgba(59, 130, 246, 0.3)";
            ctx.lineWidth = 2;
            
            const gridSize = w / 8;
            for (let i = 0; i <= 8; i++) {
              ctx.beginPath();
              ctx.moveTo(i * gridSize, 0);
              ctx.lineTo(i * gridSize, h);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(0, i * gridSize);
              ctx.lineTo(w, i * gridSize);
              ctx.stroke();
            }
          }
        },
        {
          id: "carbon-fiber",
          name: "Carbon Fiber",
          category: "pattern",
          preview: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100'%3E%3Crect fill='%23171717' width='100' height='100'/%3E%3Ccircle cx='25' cy='25' r='15' fill='%23262626' opacity='0.5'/%3E%3Ccircle cx='75' cy='25' r='15' fill='%23262626' opacity='0.5'/%3E%3Ccircle cx='25' cy='75' r='15' fill='%23262626' opacity='0.5'/%3E%3Ccircle cx='75' cy='75' r='15' fill='%23262626' opacity='0.5'/%3E%3C/svg%3E",
          generate: (canvas) => {
            const ctx = canvas.getContext("2d");
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = "#171717";
            ctx.fillRect(0, 0, w, h);
            
            const circleSize = w / 8;
            const spacing = w / 4;
            
            ctx.fillStyle = "rgba(38, 38, 38, 0.5)";
            for (let y = 0; y < h; y += spacing) {
              for (let x = 0; x < w; x += spacing) {
                ctx.beginPath();
                ctx.arc(x + spacing / 2, y + spacing / 2, circleSize, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          }
        },
        {
          id: "gradient-green",
          name: "Matrix Green",
          category: "solid",
          preview: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%2310b981'/%3E%3Cstop offset='100%25' style='stop-color:%2306b6d4'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23g)' width='100' height='100'/%3E%3C/svg%3E",
          generate: (canvas) => {
            const ctx = canvas.getContext("2d");
            const grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            grad.addColorStop(0, "#10b981");
            grad.addColorStop(1, "#06b6d4");
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        }
      ];

      // ====== Modal ======
      function openModal() {
        const modal = document.getElementById("modal");
        modal.classList.add("active");
        isModalOpen = true;

        if (!renderer) {
          setTimeout(() => {
            initThree();
            
            if (!hasSeenTutorial) {
              setTimeout(showTutorial, 1000);
            }
          }, 60);
        } else {
          restoreAutoSave();
        }
      }
      
      function closeModal() {
        if (isEditingLogo) cancelLogoEdit();
        const modal = document.getElementById("modal");
        modal.classList.remove("active");
        isModalOpen = false;
      }

      // ====== UI Handlers ======
      function selectSide(side, el) {
        if (isEditingLogo) {
          cancelLogoEdit();
        }
        
        currentSide = side;

        document
          .querySelectorAll(".segmented[aria-label='PC sides'] .seg-btn")
          .forEach((btn) => {
            btn.classList.remove("active");
            btn.setAttribute("aria-pressed", "false");
          });
        if (el) {
          el.classList.add("active");
          el.setAttribute("aria-pressed", "true");
        } else {
          const b = [...document.querySelectorAll(
            ".segmented[aria-label='PC sides'] .seg-btn"
          )].find((x) => x.textContent.trim().toLowerCase() === side);
          if (b) {
            b.classList.add("active");
            b.setAttribute("aria-pressed", "true");
          }
        }
        updateUploadButtonLabel();
        showInlineToast(`${capitalize(side)} panel selected`);
      }

      function setPrintMode(mode, el) {
        printMode = mode;
        const btns = document.querySelectorAll(
          ".segmented[aria-label='Print mode'] .seg-btn"
        );
        btns.forEach((b) => {
          b.classList.remove("active");
          b.setAttribute("aria-pressed", "false");
        });
        el.classList.add("active");
        el.setAttribute("aria-pressed", "true");

        const hint = document.getElementById("mode-hint");
        if (mode === "full") {
          hint.textContent = "Fill the entire panel with your image.";
        } else {
          hint.textContent = "Place a smaller logo and position it interactively.";
        }
        updateUploadButtonLabel();
      }

      function updateUploadButtonLabel() {
        const btn = document.getElementById("uploadBtn");
        const emoji = printMode === "full" ? "üì§" : "üè∑Ô∏è";
        const action = printMode === "full" ? "Upload image for " : "Upload logo for ";
        btn.textContent = emoji + " " + action + capitalize(currentSide);
      }

      function triggerUpload() {
        if (isEditingLogo) return;
        document.getElementById("fileInput").click();
      }

      // ====== View Mode ====== (FIXED)
      function setViewMode(mode) {
        viewMode = mode;
        
        document.querySelectorAll(".view-mode-btn").forEach(btn => {
          btn.classList.remove("active");
        });
        event.target.classList.add("active");
        
        const container = document.getElementById("canvas-container");
        const threeView = document.getElementById("three-view");
        const editorView = document.getElementById("editor-view");
        
        // Reset any existing split mode class
        container.classList.remove("split-mode");
        
        if (mode === "3d-only") {
          container.style.gridTemplateColumns = "1fr";
          threeView.style.display = "block";
          editorView.classList.remove("active");
        } else if (mode === "split") {
          // FIX: Always show both views in split mode
          container.style.gridTemplateColumns = "1fr 1fr";
          container.classList.add("split-mode");
          threeView.style.display = "block";
          editorView.classList.add("active");
          
          // If there's an image being edited, show it
          if (isEditingLogo && editorImg) {
            resizeEditorCanvas();
            drawEditor();
          } else {
            // Show placeholder message
            const ctx = editorCtx;
            ctx.fillStyle = "#1a1a2e";
            ctx.fillRect(0, 0, TEXTURE_SIZE, TEXTURE_SIZE);
            ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
            ctx.font = "24px Inter, Arial";
            ctx.textAlign = "center";
            ctx.fillText("Upload a logo to edit here", TEXTURE_SIZE/2, TEXTURE_SIZE/2);
          }
        } else if (mode === "2d-only") {
          container.style.gridTemplateColumns = "1fr";
          threeView.style.display = "none";
          editorView.classList.add("active");
          
          if (isEditingLogo && editorImg) {
            resizeEditorCanvas();
            drawEditor();
          } else {
            // Show placeholder
            const ctx = editorCtx;
            ctx.fillStyle = "#1a1a2e";
            ctx.fillRect(0, 0, TEXTURE_SIZE, TEXTURE_SIZE);
            ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
            ctx.font = "24px Inter, Arial";
            ctx.textAlign = "center";
            ctx.fillText("Upload a logo to edit here", TEXTURE_SIZE/2, TEXTURE_SIZE/2);
          }
        }
        
        onWindowResize();
      }

      // ====== File Upload Handling ======
      function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (file.size > 10 * 1024 * 1024) {
          showToast("‚ö†Ô∏è Large file - this may take a moment", false);
        }

        document.getElementById("upload-loading").classList.add("active");

        const reader = new FileReader();
        reader.onload = function (e) {
          const dataUrl = e.target.result;
          
          const img = new Image();
          img.onload = () => {
            const quality = getImageQuality(img.width, img.height);
            
            if (quality.level === "low") {
              document.getElementById("upload-loading").classList.remove("active");
              showQualityWarning(quality, () => {
                document.getElementById("upload-loading").classList.add("active");
                proceedWithUpload(dataUrl);
              });
            } else {
              if (quality.level === "medium") {
                showToast(`‚ö†Ô∏è ${quality.message}`, false);
              }
              proceedWithUpload(dataUrl);
            }
          };
          img.src = dataUrl;
        };
        reader.readAsDataURL(file);
        event.target.value = "";
      }

      function getImageQuality(w, h) {
        const minDim = Math.min(w, h);
        
        if (minDim < 512) {
          return {
            level: "low",
            message: "Image resolution is low. Result may appear pixelated.",
            recommendation: "Use images at least 1024√ó1024px for best quality."
          };
        } else if (minDim < 1024) {
          return {
            level: "medium",
            message: "Image quality acceptable, but higher resolution recommended."
          };
        } else {
          return {
            level: "high",
            message: "Great quality!"
          };
        }
      }

      function showQualityWarning(quality, onProceed) {
        const overlay = document.createElement("div");
        overlay.className = "modal active";
        overlay.style.zIndex = "11000";
        overlay.innerHTML = `
          <div style="position: fixed; inset: 0; display: grid; place-items: center;">
            <div style="
              background: linear-gradient(180deg, rgba(22, 28, 56, 0.98), rgba(14, 18, 38, 0.98));
              border: 1px solid var(--border);
              border-radius: 20px;
              padding: 24px;
              max-width: 400px;
              box-shadow: var(--shadow);
            ">
              <h3 style="margin: 0 0 12px 0; color: var(--danger);">‚ö†Ô∏è Low Image Quality</h3>
              <p style="color: var(--muted); margin: 0 0 16px 0; line-height: 1.6;">
                ${quality.message}<br><br>
                <strong>${quality.recommendation}</strong>
              </p>
              <div style="display: flex; gap: 10px;">
                <button class="btn btn-primary" style="flex: 1;" onclick="this.closest('.modal').remove(); proceedWithUploadCallback();">
                  Use Anyway
                </button>
                <button class="btn" style="flex: 1;" onclick="this.closest('.modal').remove(); document.getElementById('upload-loading').classList.remove('active');">
                  Cancel
                </button>
              </div>
            </div>
          </div>
        `;
        document.body.appendChild(overlay);
        
        window.proceedWithUploadCallback = onProceed;
      }

      function proceedWithUpload(dataUrl) {
        backupCurrentSide();

        if (printMode === "full") {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.onload = () => {
            applyFullPanelImage(img);
            document.getElementById("upload-loading").classList.remove("active");
            showToast(`‚úì Image applied to ${capitalize(currentSide)} panel`, true);
          };
          img.onerror = () => {
            document.getElementById("upload-loading").classList.remove("active");
            showToast("‚ùå Failed to load image", false);
          };
          img.src = dataUrl;
        } else {
          setTimeout(() => {
            startLogoEditor(dataUrl);
            document.getElementById("upload-loading").classList.remove("active");
          }, 100);
        }
      }

      // ====== Full Panel Apply ======
      function applyFullPanelImage(img) {
        const baseCanvas = document.createElement("canvas");
        baseCanvas.width = TEXTURE_SIZE;
        baseCanvas.height = TEXTURE_SIZE;
        const ctx = baseCanvas.getContext("2d");

        const iw = img.width;
        const ih = img.height;
        const scale = Math.max(TEXTURE_SIZE / iw, TEXTURE_SIZE / ih);
        const sw = iw * scale;
        const sh = ih * scale;
        const sx = (TEXTURE_SIZE - sw) / 2;
        const sy = (TEXTURE_SIZE - sh) / 2;

        ctx.fillStyle = "#1a1a2e";
        ctx.fillRect(0, 0, TEXTURE_SIZE, TEXTURE_SIZE);
        ctx.drawImage(img, sx, sy, sw, sh);

        const newTex = new THREE.CanvasTexture(baseCanvas);
        sideTextures[currentSide] = newTex;

        const idx = sideIndex(currentSide);
        pcCase.material[idx].map = newTex;
        pcCase.material[idx].needsUpdate = true;
        
        autoSave();
      }

      // ====== 2D Logo Editor ======
      function startLogoEditor(dataUrl) {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          editorImg = img;
          editorImageNatural = { w: img.width, h: img.height };

          editorTransform = {
            x: 0.5,
            y: 0.5,
            scale: 0.3,
            rot: 0
          };

          isEditingLogo = true;
          
          setViewMode("split");
          document.getElementById("panel-editor-toolbar").style.display = "flex";
          
          document.getElementById("editor-panel-name").textContent = 
            capitalize(currentSide) + " Panel";
          document.getElementById("editor-dimensions").textContent = 
            `${TEXTURE_SIZE} √ó ${TEXTURE_SIZE} px`;
          
          resizeEditorCanvas();
          drawEditor();
        };
        img.onerror = () => {
          showToast("‚ùå Failed to load logo image", false);
        };
        img.src = dataUrl;
      }

      function applyLogoToPanel() {
        if (!editorImg) return;

        const outCanvas = document.createElement("canvas");
        outCanvas.width = TEXTURE_SIZE;
        outCanvas.height = TEXTURE_SIZE;
        const out = outCanvas.getContext("2d");

        const base = extractCanvasFromTexture(
          sideTextures[currentSide],
          TEXTURE_SIZE,
          TEXTURE_SIZE
        );
        out.drawImage(base, 0, 0, TEXTURE_SIZE, TEXTURE_SIZE);

        const texX = editorTransform.x * TEXTURE_SIZE;
        const texY = editorTransform.y * TEXTURE_SIZE;
        
        const logoPixelSize = editorTransform.scale * TEXTURE_SIZE;
        const imgAspect = editorImageNatural.w / editorImageNatural.h;
        const logoW = logoPixelSize * Math.sqrt(imgAspect);
        const logoH = logoPixelSize / Math.sqrt(imgAspect);

        out.save();
        out.translate(texX, texY);
        out.rotate(editorTransform.rot);
        out.drawImage(editorImg, -logoW / 2, -logoH / 2, logoW, logoH);
        out.restore();

        const newTex = new THREE.CanvasTexture(outCanvas);
        sideTextures[currentSide] = newTex;
        const idx = sideIndex(currentSide);
        pcCase.material[idx].map = newTex;
        pcCase.material[idx].needsUpdate = true;

        cancelLogoEdit();
        showToast(`‚úì Logo applied to ${capitalize(currentSide)} panel`, true);
        autoSave();
      }

      function cancelLogoEdit() {
        isEditingLogo = false;
        editorImg = null;
        setViewMode("3d-only");
        document.getElementById("panel-editor-toolbar").style.display = "none";
      }

      // ====== Editor Drawing - CANVA STYLE ====== (IMPROVED)
      function drawEditor() {
        if (!editorImg) return;
        const ctx = editorCtx;
        const c = editorCanvas;
        
        ctx.clearRect(0, 0, TEXTURE_SIZE, TEXTURE_SIZE);
        
        const baseTex = sideTextures[currentSide];
        if (baseTex && baseTex.image) {
          ctx.drawImage(baseTex.image, 0, 0, TEXTURE_SIZE, TEXTURE_SIZE);
        } else {
          ctx.fillStyle = "#1a1a2e";
          ctx.fillRect(0, 0, TEXTURE_SIZE, TEXTURE_SIZE);
        }

        drawGrid(ctx, TEXTURE_SIZE, TEXTURE_SIZE);
        drawSnapPoints(ctx, TEXTURE_SIZE, TEXTURE_SIZE);

        const canvasX = editorTransform.x * TEXTURE_SIZE;
        const canvasY = editorTransform.y * TEXTURE_SIZE;
        
        const logoPixelSize = editorTransform.scale * TEXTURE_SIZE;
        const imgAspect = editorImageNatural.w / editorImageNatural.h;
        const w = logoPixelSize * Math.sqrt(imgAspect);
        const h = logoPixelSize / Math.sqrt(imgAspect);

        ctx.save();
        ctx.translate(canvasX, canvasY);
        ctx.rotate(editorTransform.rot);
        
        // Draw the image first
        ctx.drawImage(editorImg, -w / 2, -h / 2, w, h);
        
        // Canva-style bounding box
        ctx.strokeStyle = "#6d8cff";
        ctx.lineWidth = 2;
        ctx.strokeRect(-w / 2, -h / 2, w, h);
        
        // Corner handles (larger, circular)
        const corners = [
          [-w/2, -h/2], [w/2, -h/2], 
          [w/2, h/2], [-w/2, h/2]
        ];
        
        ctx.fillStyle = "#ffffff";
        ctx.strokeStyle = "#6d8cff";
        ctx.lineWidth = 3;
        
        corners.forEach(([cx, cy]) => {
          ctx.beginPath();
          ctx.arc(cx, cy, HANDLE_SIZE/2, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        });
        
        // Rotation handle (at top, above bounding box)
        const rotHandleY = -h/2 - 40;
        
        // Line connecting to rotation handle
        ctx.strokeStyle = "#6d8cff";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(0, -h/2);
        ctx.lineTo(0, rotHandleY);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Rotation handle circle
        ctx.beginPath();
        ctx.arc(0, rotHandleY, HANDLE_SIZE/2, 0, Math.PI * 2);
        ctx.fillStyle = "#ffffff";
        ctx.fill();
        ctx.strokeStyle = "#6d8cff";
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Rotation icon
        ctx.save();
        ctx.translate(0, rotHandleY);
        ctx.strokeStyle = "#6d8cff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, 6, 0, Math.PI * 1.5);
        ctx.stroke();
        // Arrow
        ctx.beginPath();
        ctx.moveTo(-6, 0);
        ctx.lineTo(-3, -3);
        ctx.lineTo(-3, 3);
        ctx.closePath();
        ctx.fillStyle = "#6d8cff";
        ctx.fill();
        ctx.restore();
        
        ctx.restore();

        // Center guides
        ctx.strokeStyle = "rgba(109, 140, 255, 0.3)";
        ctx.lineWidth = 1;
        ctx.setLineDash([6, 6]);
        ctx.beginPath();
        ctx.moveTo(TEXTURE_SIZE / 2, 0);
        ctx.lineTo(TEXTURE_SIZE / 2, TEXTURE_SIZE);
        ctx.moveTo(0, TEXTURE_SIZE / 2);
        ctx.lineTo(TEXTURE_SIZE, TEXTURE_SIZE / 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      function drawGrid(ctx, w, h) {
        const step = w / 8;
        ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
        ctx.lineWidth = 1;
        
        for (let x = step; x < w; x += step) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, h);
          ctx.stroke();
        }
        for (let y = step; y < h; y += step) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(w, y);
          ctx.stroke();
        }
        
        ctx.strokeStyle = "rgba(109, 140, 255, 0.4)";
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, w, h);
      }

      function drawSnapPoints(ctx, w, h) {
        const points = [
          { x: 0.5, y: 0.5, size: 12 },
          { x: 0.25, y: 0.25, size: 8 },
          { x: 0.75, y: 0.25, size: 8 },
          { x: 0.25, y: 0.75, size: 8 },
          { x: 0.75, y: 0.75, size: 8 },
        ];
        
        ctx.save();
        points.forEach(pt => {
          const px = pt.x * w;
          const py = pt.y * h;
          
          const isNear = Math.hypot(
            editorTransform.x - pt.x, 
            editorTransform.y - pt.y
          ) < SNAP_THRESHOLD;
          
          ctx.fillStyle = isNear ? "#6d8cff" : "rgba(109, 140, 255, 0.3)";
          ctx.beginPath();
          ctx.arc(px, py, pt.size, 0, Math.PI * 2);
          ctx.fill();
          
          if (isNear) {
            ctx.strokeStyle = "#6d8cff";
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        });
        ctx.restore();
      }

      function snapPosition(x, y) {
        const snapPoints = [
          { x: 0.5, y: 0.5 },
          { x: 0.25, y: 0.25 },
          { x: 0.75, y: 0.25 },
          { x: 0.25, y: 0.75 },
          { x: 0.75, y: 0.75 },
        ];
        
        let snappedX = x;
        let snappedY = y;
        let didSnap = false;
        
        snapPoints.forEach(point => {
          if (Math.abs(x - point.x) < SNAP_THRESHOLD) {
            snappedX = point.x;
            didSnap = true;
          }
          if (Math.abs(y - point.y) < SNAP_THRESHOLD) {
            snappedY = point.y;
            didSnap = true;
          }
        });
        
        return { x: snappedX, y: snappedY, didSnap };
      }

      // Helper to get handle at position
      function getHandleAtPosition(mx, my) {
        const canvasX = editorTransform.x * TEXTURE_SIZE;
        const canvasY = editorTransform.y * TEXTURE_SIZE;
        
        const logoPixelSize = editorTransform.scale * TEXTURE_SIZE;
        const imgAspect = editorImageNatural.w / editorImageNatural.h;
        const w = logoPixelSize * Math.sqrt(imgAspect);
        const h = logoPixelSize / Math.sqrt(imgAspect);
        
        // Transform mouse to logo space
        const cos = Math.cos(-editorTransform.rot);
        const sin = Math.sin(-editorTransform.rot);
        const dx = mx - canvasX;
        const dy = my - canvasY;
        const localX = dx * cos - dy * sin;
        const localY = dx * sin + dy * cos;
        
        // Check rotation handle
        const rotHandleY = -h/2 - 40;
        if (Math.hypot(localX, localY - rotHandleY) < HANDLE_SIZE) {
          return { type: 'rotate' };
        }
        
        // Check corners
        const corners = [
          { x: -w/2, y: -h/2, name: 'tl' },
          { x: w/2, y: -h/2, name: 'tr' },
          { x: w/2, y: h/2, name: 'br' },
          { x: -w/2, y: h/2, name: 'bl' }
        ];
        
        for (const corner of corners) {
          if (Math.hypot(localX - corner.x, localY - corner.y) < HANDLE_SIZE) {
            return { type: 'scale', corner: corner.name };
          }
        }
        
        // Check if inside image bounds
        if (Math.abs(localX) < w/2 && Math.abs(localY) < h/2) {
          return { type: 'move' };
        }
        
        return null;
      }

      // ====== Editor Events - CANVA STYLE ====== (IMPROVED)
      function setupEditorEvents() {
        const c = editorCanvas;

        window.addEventListener("resize", () => {
          if (isEditingLogo) resizeEditorCanvas();
        });

        c.addEventListener("mousedown", (e) => {
          if (!isEditingLogo || !editorImg) return;
          
          const rect = c.getBoundingClientRect();
          const mx = ((e.clientX - rect.left) / rect.width) * TEXTURE_SIZE;
          const my = ((e.clientY - rect.top) / rect.height) * TEXTURE_SIZE;
          
          const handle = getHandleAtPosition(mx, my);
          
          if (handle) {
            if (handle.type === 'move') {
              editorDragging = true;
              c.style.cursor = 'move';
            } else if (handle.type === 'rotate') {
              editorRotating = true;
              c.style.cursor = 'grab';
            } else if (handle.type === 'scale') {
              editorScaling = true;
              editorScaleCorner = handle.corner;
              c.style.cursor = 'nwse-resize';
            }
            
            editorLast = { x: mx / TEXTURE_SIZE, y: my / TEXTURE_SIZE };
          }
        });
        
        c.addEventListener("mousemove", (e) => {
          if (!isEditingLogo || !editorImg) return;
          
          const rect = c.getBoundingClientRect();
          const mx = ((e.clientX - rect.left) / rect.width) * TEXTURE_SIZE;
          const my = ((e.clientY - rect.top) / rect.height) * TEXTURE_SIZE;
          
          // Update cursor based on what's under mouse
          if (!editorDragging && !editorRotating && !editorScaling) {
            const handle = getHandleAtPosition(mx, my);
            if (handle) {
              if (handle.type === 'move') c.style.cursor = 'move';
              else if (handle.type === 'rotate') c.style.cursor = 'grab';
              else if (handle.type === 'scale') c.style.cursor = 'nwse-resize';
            } else {
              c.style.cursor = 'default';
            }
          }
        });
        
        window.addEventListener("mousemove", (e) => {
          if (!isEditingLogo || !editorImg) return;
          
          const rect = c.getBoundingClientRect();
          const nx = ((e.clientX - rect.left) / rect.width);
          const ny = ((e.clientY - rect.top) / rect.height);
          
          if (editorDragging) {
            editorTransform.x += nx - editorLast.x;
            editorTransform.y += ny - editorLast.y;
            
            const snapped = snapPosition(editorTransform.x, editorTransform.y);
            editorTransform.x = snapped.x;
            editorTransform.y = snapped.y;
            
            if (snapped.didSnap) {
              navigator.vibrate && navigator.vibrate(10);
            }
            
            editorTransform.x = clamp(editorTransform.x, 0, 1);
            editorTransform.y = clamp(editorTransform.y, 0, 1);
            
            editorLast = { x: nx, y: ny };
            drawEditor();
          } else if (editorRotating) {
            const centerX = editorTransform.x;
            const centerY = editorTransform.y;
            
            const angle1 = Math.atan2(editorLast.y - centerY, editorLast.x - centerX);
            const angle2 = Math.atan2(ny - centerY, nx - centerX);
            
            editorTransform.rot += angle2 - angle1;
            
            editorLast = { x: nx, y: ny };
            drawEditor();
          } else if (editorScaling) {
            const centerX = editorTransform.x;
            const centerY = editorTransform.y;
            
            const dist1 = Math.hypot(editorLast.x - centerX, editorLast.y - centerY);
            const dist2 = Math.hypot(nx - centerX, ny - centerY);
            
            const scaleFactor = dist2 / dist1;
            editorTransform.scale *= scaleFactor;
            editorTransform.scale = clamp(editorTransform.scale, 0.05, 1.5);
            
            editorLast = { x: nx, y: ny };
            drawEditor();
          }
        });
        
        window.addEventListener("mouseup", () => {
          editorDragging = false;
          editorRotating = false;
          editorScaling = false;
          editorScaleCorner = null;
          if (c) c.style.cursor = 'default';
        });

        c.addEventListener("wheel", (e) => {
            if (!isEditingLogo) return;
            e.preventDefault();
            const factor = e.shiftKey ? 1.02 : 1.08;
            const dir = e.deltaY < 0 ? factor : 1 / factor;
            editorTransform.scale *= dir;
            editorTransform.scale = clamp(editorTransform.scale, 0.05, 1.5);
            drawEditor();
          },
          { passive: false }
        );

        // Touch events (same Canva-style logic)
        c.addEventListener("touchstart", (e) => {
            if (!isEditingLogo || !editorImg) return;
            e.preventDefault();
            
            const rect = c.getBoundingClientRect();
            const touch = e.touches[0];
            const mx = ((touch.clientX - rect.left) / rect.width) * TEXTURE_SIZE;
            const my = ((touch.clientY - rect.top) / rect.height) * TEXTURE_SIZE;
            
            editorTouches = [...e.touches];
            
            if (e.touches.length === 1) {
              const handle = getHandleAtPosition(mx, my);
              if (handle && handle.type === 'move') {
                editorDragging = true;
                editorLast = {
                  x: (touch.clientX - rect.left) / rect.width,
                  y: (touch.clientY - rect.top) / rect.height
                };
              }
            }
          },
          { passive: false }
        );
        
        c.addEventListener("touchmove", (e) => {
            if (!isEditingLogo || !editorImg) return;
            e.preventDefault();
            const touches = [...e.touches];
            const rect = c.getBoundingClientRect();
            
            if (touches.length === 1 && editorDragging) {
              const nx = (touches[0].clientX - rect.left) / rect.width;
              const ny = (touches[0].clientY - rect.top) / rect.height;
              
              editorTransform.x += nx - editorLast.x;
              editorTransform.y += ny - editorLast.y;
              
              const snapped = snapPosition(editorTransform.x, editorTransform.y);
              editorTransform.x = snapped.x;
              editorTransform.y = snapped.y;
              
              if (snapped.didSnap) {
                navigator.vibrate && navigator.vibrate(10);
              }
              
              editorTransform.x = clamp(editorTransform.x, 0, 1);
              editorTransform.y = clamp(editorTransform.y, 0, 1);
              
              editorLast = { x: nx, y: ny };
              drawEditor();
            } else if (touches.length === 2 && editorTouches.length === 2) {
              const [a0, b0] = editorTouches;
              const [a1, b1] = touches;

              // Pinch to scale
              const d0 = Math.hypot(a0.clientX - b0.clientX, a0.clientY - b0.clientY);
              const d1 = Math.hypot(a1.clientX - b1.clientX, a1.clientY - b1.clientY);
              editorTransform.scale *= d1 / d0;
              editorTransform.scale = clamp(editorTransform.scale, 0.05, 1.5);

              // Twist to rotate
              const ang0 = Math.atan2(b0.clientY - a0.clientY, b0.clientX - a0.clientX);
              const ang1 = Math.atan2(b1.clientY - a1.clientY, b1.clientX - a1.clientX);
              editorTransform.rot += ang1 - ang0;

              editorTouches = touches;
              drawEditor();
            }
          },
          { passive: false }
        );
        
        c.addEventListener("touchend", (e) => {
            if (!isEditingLogo) return;
            e.preventDefault();
            editorDragging = false;
            editorRotating = false;
            editorScaling = false;
            editorTouches = [...e.touches];
          },
          { passive: false }
        );

        // Keyboard shortcuts
        window.addEventListener("keydown", (e) => {
          if (!isEditingLogo) return;
          
          if (e.key === "Escape") {
            cancelLogoEdit();
          } else if (e.key === "Enter") {
            applyLogoToPanel();
          } else if (e.key.toLowerCase() === "r") {
            editorTransform.rot += e.shiftKey ? 0.01 : 0.1;
            drawEditor();
          } else if (e.key.toLowerCase() === "c") {
            centerLogo();
          } else if (e.key === "+" || e.key === "=") {
            scaleLogo(e.shiftKey ? 1.02 : 1.1);
          } else if (e.key === "-" || e.key === "_") {
            scaleLogo(e.shiftKey ? 0.98 : 0.9);
          } else if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(e.key)) {
            e.preventDefault();
            const step = e.shiftKey ? 0.001 : 0.01;
            if (e.key === "ArrowLeft") editorTransform.x -= step;
            if (e.key === "ArrowRight") editorTransform.x += step;
            if (e.key === "ArrowUp") editorTransform.y -= step;
            if (e.key === "ArrowDown") editorTransform.y += step;
            editorTransform.x = clamp(editorTransform.x, 0, 1);
            editorTransform.y = clamp(editorTransform.y, 0, 1);
            drawEditor();
          }
        });

        // Global keyboard shortcuts
        window.addEventListener("keydown", (e) => {
          if ((e.ctrlKey || e.metaKey) && e.key === "z" && !e.shiftKey) {
            e.preventDefault();
            undoLast();
          }
        });
      }

      function resizeEditorCanvas() {
        const container = document.getElementById("editor-view");
        if (!container) return;
        
        editorCanvas.width = TEXTURE_SIZE;
        editorCanvas.height = TEXTURE_SIZE;
        
        const rect = container.getBoundingClientRect();
        const maxSize = Math.min(rect.width - 40, rect.height - 40, 800);
        editorCanvas.style.width = maxSize + "px";
        editorCanvas.style.height = maxSize + "px";
        
        if (isEditingLogo && editorImg) {
          drawEditor();
        }
      }

      // ====== Toolbar Functions ======
      function resetLogoTransform() {
        editorTransform = { x: 0.5, y: 0.5, scale: 0.3, rot: 0 };
        drawEditor();
        showToast("‚Ü∫ Transform reset", false);
      }

      function centerLogo() {
        editorTransform.x = 0.5;
        editorTransform.y = 0.5;
        drawEditor();
        navigator.vibrate && navigator.vibrate(10);
        showInlineToast("‚äï Logo centered");
      }

      function rotateLogo(degrees) {
        editorTransform.rot += degrees * (Math.PI / 180);
        drawEditor();
        navigator.vibrate && navigator.vibrate(10);
      }

      function scaleLogo(factor) {
        editorTransform.scale *= factor;
        editorTransform.scale = clamp(editorTransform.scale, 0.05, 1.5);
        drawEditor();
      }

      // ====== Export Functions ======
      function exportCurrentSide() {
        exportPanel(currentSide);
      }
      
      function exportCurrentPanel() {
        exportPanel(currentSide);
      }
      
      function exportPanel(sideName) {
        const canvas = extractCanvasFromTexture(
          sideTextures[sideName],
          TEXTURE_SIZE,
          TEXTURE_SIZE
        );
        
        canvas.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `pc-panel-${sideName}-${TEXTURE_SIZE}x${TEXTURE_SIZE}.png`;
          a.click();
          URL.revokeObjectURL(url);
          showToast(`‚úì ${capitalize(sideName)} panel exported`, false);
        }, "image/png");
      }
      
      function exportAll() {
        const sides = ["front", "back", "left", "right", "top", "bottom"];
        sides.forEach((side, i) => {
          setTimeout(() => exportPanel(side), i * 300);
        });
        showToast("‚úì Exporting all 6 panels...", false);
      }

      // ====== Apply to Multiple Sides ======
      function applyToAllSides() {
        if (!confirm(`Apply current ${capitalize(currentSide)} design to all 6 sides?`)) {
          return;
        }
        
        backupCurrentSide();
        
        const sourceTex = sideTextures[currentSide];
        const sourceCanvas = extractCanvasFromTexture(sourceTex, TEXTURE_SIZE, TEXTURE_SIZE);
        
        ["front", "back", "left", "right", "top", "bottom"].forEach(side => {
          if (side === currentSide) return;
          
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = TEXTURE_SIZE;
          tempCanvas.height = TEXTURE_SIZE;
          const ctx = tempCanvas.getContext("2d");
          ctx.drawImage(sourceCanvas, 0, 0);
          
          const newTex = new THREE.CanvasTexture(tempCanvas);
          sideTextures[side] = newTex;
          const idx = sideIndex(side);
          pcCase.material[idx].map = newTex;
          pcCase.material[idx].needsUpdate = true;
        });
        
        showToast("‚úì Design applied to all sides", true);
        autoSave();
      }

      function applyToGroup(group) {
        let sides = [];
        let label = "";
        
        if (group === "vertical") {
          sides = ["front", "back", "left", "right"];
          label = "vertical sides";
        } else if (group === "horizontal") {
          sides = ["top", "bottom"];
          label = "horizontal sides";
        }
        
        if (!confirm(`Apply current ${capitalize(currentSide)} design to ${label}?`)) {
          return;
        }
        
        backupCurrentSide();
        
        const sourceTex = sideTextures[currentSide];
        const sourceCanvas = extractCanvasFromTexture(sourceTex, TEXTURE_SIZE, TEXTURE_SIZE);
        
        sides.forEach(side => {
          if (side === currentSide) return;
          
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = TEXTURE_SIZE;
          tempCanvas.height = TEXTURE_SIZE;
          const ctx = tempCanvas.getContext("2d");
          ctx.drawImage(sourceCanvas, 0, 0);
          
          const newTex = new THREE.CanvasTexture(tempCanvas);
          sideTextures[side] = newTex;
          const idx = sideIndex(side);
          pcCase.material[idx].map = newTex;
          pcCase.material[idx].needsUpdate = true;
        });
        
        showToast(`‚úì Design applied to ${sides.length} sides`, true);
        autoSave();
      }

      // ====== 3D Init ======
      function initThree() {
        const container = document.getElementById("three-view");
        const loader = document.getElementById("loader");

        editorCanvas = document.getElementById("panel-editor");
        editorCtx = editorCanvas.getContext("2d");

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f0c29);

        camera = new THREE.PerspectiveCamera(
          50,
          container.clientWidth / container.clientHeight,
          0.1,
          1000
        );
        camera.position.set(0, 2, 6);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0x667eea, 1, 100);
        pointLight.position.set(-5, 5, -5);
        scene.add(pointLight);

        const pointLight2 = new THREE.PointLight(0x764ba2, 0.8, 100);
        pointLight2.position.set(5, -5, 5);
        scene.add(pointLight2);

        initializeTextures();
        createPCModel();
        setup3DInteractions(container);
        setupEditorEvents();
        populateTemplates();
        animate();

        loader.style.display = "none";
        window.addEventListener("resize", onWindowResize);
        
        restoreAutoSave();
      }

      function initializeTextures() {
        const sides = ["front", "back", "left", "right", "top", "bottom"];
        sides.forEach((side) => {
          sideTextures[side] = createDefaultTexture(side);
        });
      }

      function createDefaultTexture(sideName) {
        const canvas = document.createElement("canvas");
        canvas.width = TEXTURE_SIZE;
        canvas.height = TEXTURE_SIZE;
        const ctx = canvas.getContext("2d");
        const gradient = ctx.createLinearGradient(0, 0, TEXTURE_SIZE, TEXTURE_SIZE);
        gradient.addColorStop(0, "#2b3a8a");
        gradient.addColorStop(1, "#6a3aa6");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, TEXTURE_SIZE, TEXTURE_SIZE);

        ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
        ctx.font = "bold 64px Inter, Arial";
        ctx.textAlign = "center";
        ctx.fillText(sideName.toUpperCase(), TEXTURE_SIZE/2, TEXTURE_SIZE/2 - 30);
        ctx.font = "28px Inter, Arial";
        ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
        ctx.fillText("Upload Design", TEXTURE_SIZE/2, TEXTURE_SIZE/2 + 20);

        return new THREE.CanvasTexture(canvas);
      }

      function createPCModel() {
        pcGroup = new THREE.Group();
        const size = pcSizes[currentSize];

        const materials = [
          new THREE.MeshStandardMaterial({ map: sideTextures.right, metalness: 0.3, roughness: 0.7 }),
          new THREE.MeshStandardMaterial({ map: sideTextures.left, metalness: 0.3, roughness: 0.7 }),
          new THREE.MeshStandardMaterial({ map: sideTextures.top, metalness: 0.3, roughness: 0.7 }),
          new THREE.MeshStandardMaterial({ map: sideTextures.bottom, metalness: 0.3, roughness: 0.7 }),
          new THREE.MeshStandardMaterial({ map: sideTextures.front, metalness: 0.3, roughness: 0.7 }),
          new THREE.MeshStandardMaterial({ map: sideTextures.back, metalness: 0.3, roughness: 0.7 }),
        ];

        const caseGeometry = new THREE.BoxGeometry(size.width, size.height, size.depth);
        pcCase = new THREE.Mesh(caseGeometry, materials);
        pcGroup.add(pcCase);

        const edges = new THREE.EdgesGeometry(caseGeometry);
        hoverOutline = new THREE.LineSegments(
          edges,
          new THREE.LineBasicMaterial({ color: 0x6d8cff, linewidth: 2, transparent: true, opacity: 0.0 })
        );
        pcGroup.add(hoverOutline);

        const glassGeometry = new THREE.PlaneGeometry(size.width * 0.9, size.height * 0.9);
        const glassMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x667eea,
          transparent: true,
          opacity: 0.18,
          metalness: 0.9,
          roughness: 0.1,
          clearcoat: 1,
        });
        const glass = new THREE.Mesh(glassGeometry, glassMaterial);
        glass.position.z = size.depth / 2 + 0.01;
        pcGroup.add(glass);

        scene.add(pcGroup);
      }

      function animate() {
        requestAnimationFrame(animate);
        if (isModalOpen && pcGroup && !isEditingLogo) {
          pcGroup.rotation.y += 0.003;
          renderer.render(scene, camera);
        } else if (isModalOpen && renderer) {
          renderer.render(scene, camera);
        }
      }

      function onWindowResize() {
        const container = document.getElementById("three-view");
        if (!container || !renderer) return;

        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }

      function setup3DInteractions(container) {
        container.addEventListener("mousemove", onMouseMove);
        container.addEventListener("click", onMouseClick);
        
        container.addEventListener("wheel", (e) => {
            e.preventDefault();
            camera.position.z = clamp(camera.position.z + e.deltaY * 0.01, 3, 10);
          },
          { passive: false }
        );

        let isDragging = false;
        let prev = { x: 0, y: 0 };
        
        container.addEventListener("mousedown", (e) => {
          isDragging = true;
          prev = { x: e.clientX, y: e.clientY };
        });
        
        window.addEventListener("mousemove", (e) => {
          if (!isDragging) return;
          const dx = e.clientX - prev.x;
          const dy = e.clientY - prev.y;
          pcGroup.rotation.y += dx * 0.01;
          pcGroup.rotation.x = clamp(pcGroup.rotation.x + dy * 0.01, -Math.PI / 4, Math.PI / 4);
          prev = { x: e.clientX, y: e.clientY };
        });
        
        window.addEventListener("mouseup", () => (isDragging = false));
      }

      function onMouseMove(e) {
        if (!pcCase) return;
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(pcCase, true);
        hoverOutline.material.opacity = intersects.length ? 0.4 : 0.0;
      }

      function onMouseClick(e) {
        if (!pcCase) return;
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(pcCase, true);
        if (intersects.length) {
          const faceIndex = intersects[0].face.materialIndex;
          const side = sideFromMaterialIndex(faceIndex);
          selectSide(side, null);
        }
      }

      // ====== Templates ======
      function populateTemplates() {
        const grid = document.getElementById("template-grid");
        if (!grid) return;
        
        const visibleTemplates = templateLibrary.slice(0, 6);
        
        grid.innerHTML = visibleTemplates.map(template => `
          <div class="template-item" onclick="applyTemplate('${template.id}')">
            <img src="${template.preview}" alt="${template.name}">
            <div class="template-name">${template.name}</div>
          </div>
        `).join("");
      }

      function applyTemplate(templateId) {
        const template = templateLibrary.find(t => t.id === templateId);
        if (!template) return;
        
        backupCurrentSide();
        
        const canvas = document.createElement("canvas");
        canvas.width = TEXTURE_SIZE;
        canvas.height = TEXTURE_SIZE;
        
        template.generate(canvas);
        
        const newTex = new THREE.CanvasTexture(canvas);
        sideTextures[currentSide] = newTex;
        const idx = sideIndex(currentSide);
        pcCase.material[idx].map = newTex;
        pcCase.material[idx].needsUpdate = true;
        
        showToast(`‚úì Applied "${template.name}" template`, true);
        autoSave();
      }

      // ====== Tutorial ====== (FIXED)
      function showTutorial() {
        const steps = [
          {
            target: ".template-grid",
            title: "1Ô∏è‚É£ Quick Start Templates",
            content: "Click any template to instantly apply a professional design. Perfect for getting started!",
            position: "bottom"
          },
          {
            target: ".segmented[aria-label='PC sides']",
            title: "2Ô∏è‚É£ Choose a Side",
            content: "Select which panel of your PC case you want to customize. You can also click directly on the 3D model!",
            position: "bottom"
          },
          {
            target: ".segmented[aria-label='Print mode']",
            title: "3Ô∏è‚É£ Select Print Mode",
            content: "<strong>Full Panel:</strong> Fills entire side with your image<br><strong>Logo:</strong> Place a smaller graphic with precise control",
            position: "bottom"
          },
          {
            target: "#uploadBtn",
            title: "4Ô∏è‚É£ Upload Your Design",
            content: "Click here to upload an image. JPG, PNG, and SVG supported. We'll warn you if quality is low!",
            position: "top"
          },
          {
            target: "#three-view",
            title: "5Ô∏è‚É£ Preview in 3D",
            content: "<strong>Drag</strong> to rotate ‚Ä¢ <strong>Scroll</strong> to zoom ‚Ä¢ <strong>Click a face</strong> to select it",
            position: "center"
          }
        ];
        
        showTutorialStep(0, steps);
      }

      function showTutorialStep(index, steps) {
        if (index >= steps.length) {
          localStorage.setItem("pc-customizer-tutorial-seen", "true");
          hasSeenTutorial = true;
          return;
        }
        
        const step = steps[index];
        const target = document.querySelector(step.target);
        
        if (!target) {
          showTutorialStep(index + 1, steps);
          return;
        }
        
        // FIXED: Scroll element into view before showing tutorial
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // Wait for scroll to complete
        setTimeout(() => {
          const rect = target.getBoundingClientRect();
          
          const overlay = document.createElement("div");
          overlay.className = "tutorial-overlay";
          
          let cardStyle = "";
          let cardTop = 0;
          
          if (step.position === "bottom") {
            cardTop = rect.bottom + 20;
            // FIXED: Make sure card is visible on screen
            if (cardTop + 300 > window.innerHeight) {
              cardTop = window.innerHeight - 320;
            }
            cardStyle = `top: ${cardTop}px;`;
          } else if (step.position === "top") {
            const cardBottom = window.innerHeight - rect.top + 20;
            cardStyle = `bottom: ${cardBottom}px;`;
          } else if (step.position === "center") {
            cardStyle = `top: 50%; transform: translateX(-50%) translateY(-50%);`;
          }
          
          overlay.innerHTML = `
            <div class="tutorial-spotlight"></div>
            
            <div class="tutorial-highlight" style="
              left: ${rect.left - 8}px;
              top: ${rect.top - 8}px;
              width: ${rect.width + 16}px;
              height: ${rect.height + 16}px;
            "></div>
            
            <div class="tutorial-card" style="${cardStyle}">
              <h3 style="margin: 0 0 12px 0; color: var(--accent); font-size: 18px;">
                ${step.title}
              </h3>
              <p style="margin: 0 0 20px 0; color: var(--text); line-height: 1.6; font-size: 14px;">
                ${step.content}
              </p>
              <div style="display: flex; gap: 10px; justify-content: space-between;">
                <button class="btn" onclick="skipTutorial()" style="flex: 1;">
                  Skip Tutorial
                </button>
                <button class="btn btn-primary" onclick="nextTutorialStep()" style="flex: 1;">
                  ${index < steps.length - 1 ? 'Next ‚Üí' : 'Got it! ‚úì'}
                </button>
              </div>
              <div style="margin-top: 12px; text-align: center; color: var(--muted); font-size: 12px;">
                Step ${index + 1} of ${steps.length}
              </div>
            </div>
          `;
          
          document.body.appendChild(overlay);
          
          window.currentTutorialIndex = index;
          window.currentTutorialSteps = steps;
        }, 300);
      }

      function nextTutorialStep() {
        document.querySelector(".tutorial-overlay")?.remove();
        showTutorialStep(window.currentTutorialIndex + 1, window.currentTutorialSteps);
      }

      function skipTutorial() {
        document.querySelector(".tutorial-overlay")?.remove();
        localStorage.setItem("pc-customizer-tutorial-seen", "true");
        hasSeenTutorial = true;
      }

      // ====== Utilities ======
      function sideIndex(side) {
        return {
          right: 0,
          left: 1,
          top: 2,
          bottom: 3,
          front: 4,
          back: 5,
        }[side];
      }
      
      function sideFromMaterialIndex(i) {
        return ["right", "left", "top", "bottom", "front", "back"][i] || "front";
      }
      
      function capitalize(s) {
        return s.charAt(0).toUpperCase() + s.slice(1);
      }
      
      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }
      
      function extractCanvasFromTexture(tex, w, h) {
        const c = document.createElement("canvas");
        c.width = w;
        c.height = h;
        const ctx = c.getContext("2d");
        if (tex && tex.image) {
          try {
            ctx.drawImage(tex.image, 0, 0, w, h);
          } catch (e) {
            ctx.fillStyle = "#1a1a2e";
            ctx.fillRect(0, 0, w, h);
          }
        } else {
          ctx.fillStyle = "#1a1a2e";
          ctx.fillRect(0, 0, w, h);
        }
        return c;
      }

      // ====== Reset / Undo / Toast ======
      function resetSide() {
        backupCurrentSide();
        const idx = sideIndex(currentSide);
        sideTextures[currentSide] = createDefaultTexture(currentSide);
        pcCase.material[idx].map = sideTextures[currentSide];
        pcCase.material[idx].needsUpdate = true;
        showToast(`‚úì ${capitalize(currentSide)} panel reset`, true);
        autoSave();
      }
      
      function resetAll() {
        backupCurrentSide();
        ["front", "back", "left", "right", "top", "bottom"].forEach((side) => {
          const idx = sideIndex(side);
          sideTextures[side] = createDefaultTexture(side);
          pcCase.material[idx].map = sideTextures[side];
          pcCase.material[idx].needsUpdate = true;
        });
        showToast("‚úì All panels reset", true);
        autoSave();
      }
      
      function backupCurrentSide() {
        const tex = sideTextures[currentSide];
        const c = extractCanvasFromTexture(tex, TEXTURE_SIZE, TEXTURE_SIZE);
        
        undoStack.push({
          side: currentSide,
          texture: new THREE.CanvasTexture(c),
          timestamp: Date.now()
        });
        
        if (undoStack.length > MAX_UNDO) {
          undoStack.shift();
        }
        
        updateUndoButton();
      }
      
      function updateUndoButton() {
        const btn = document.getElementById("undo-btn");
        if (btn) {
          btn.disabled = undoStack.length === 0;
          btn.style.opacity = undoStack.length > 0 ? "1" : "0.5";
        }
      }
      
      function undoLast() {
        if (undoStack.length === 0) {
          showToast("‚ùå Nothing to undo", false);
          return;
        }
        
        const lastState = undoStack.pop();
        const idx = sideIndex(lastState.side);
        
        sideTextures[lastState.side] = lastState.texture;
        pcCase.material[idx].map = lastState.texture;
        pcCase.material[idx].needsUpdate = true;
        
        showToast(`‚Ü∂ Undid changes on ${capitalize(lastState.side)} panel`, false);
        updateUndoButton();
        autoSave();
      }
      
      function showToast(msg, showUndo) {
        const t = document.getElementById("toast");
        const txt = document.getElementById("toast-text");
        txt.textContent = msg;
        t.style.display = "flex";
        
        clearTimeout(window.toastTimeout);
        window.toastTimeout = setTimeout(() => {
          t.style.display = "none";
        }, 3000);
      }
      
      function showInlineToast(msg) {
        const t = document.getElementById("toast");
        const txt = document.getElementById("toast-text");
        txt.textContent = msg;
        t.style.display = "flex";
        
        clearTimeout(window.toastTimeout);
        window.toastTimeout = setTimeout(() => {
          t.style.display = "none";
        }, 2000);
      }

      // ====== Auto-Save ======
      function autoSave() {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => {
          const state = {
            textures: {},
            currentSide,
            printMode,
            timestamp: Date.now()
          };
          
          Object.keys(sideTextures).forEach(side => {
            const canvas = extractCanvasFromTexture(sideTextures[side], TEXTURE_SIZE, TEXTURE_SIZE);
            try {
              state.textures[side] = canvas.toDataURL("image/png", 0.5);
            } catch (e) {
              console.warn("Failed to save texture for", side);
            }
          });
          
          try {
            localStorage.setItem("pc-customizer-autosave", JSON.stringify(state));
            console.log("Auto-saved");
          } catch (e) {
            console.warn("Auto-save failed:", e);
          }
        }, 2000);
      }

      function restoreAutoSave() {
        const saved = localStorage.getItem("pc-customizer-autosave");
        if (!saved) return;
        
        try {
          const state = JSON.parse(saved);
          const age = Date.now() - state.timestamp;
          
          if (age < 24 * 60 * 60 * 1000) {
            if (confirm("Restore your last session?")) {
              let loadedCount = 0;
              Object.keys(state.textures).forEach(side => {
                const img = new Image();
                img.onload = () => {
                  const canvas = document.createElement("canvas");
                  canvas.width = TEXTURE_SIZE;
                  canvas.height = TEXTURE_SIZE;
                  const ctx = canvas.getContext("2d");
                  ctx.drawImage(img, 0, 0);
                  
                  const tex = new THREE.CanvasTexture(canvas);
                  sideTextures[side] = tex;
                  const idx = sideIndex(side);
                  if (pcCase && pcCase.material[idx]) {
                    pcCase.material[idx].map = tex;
                    pcCase.material[idx].needsUpdate = true;
                  }
                  
                  loadedCount++;
                  if (loadedCount === Object.keys(state.textures).length) {
                    showToast("‚úì Session restored", false);
                  }
                };
                img.src = state.textures[side];
              });
            }
          }
        } catch (e) {
          console.warn("Restore failed:", e);
        }
      }

      // ====== Mobile Swipe Gestures ======
      let touchStartY = 0;
      let touchEndY = 0;

      const controlsElement = document.querySelector(".controls");
      if (controlsElement) {
        controlsElement.addEventListener("touchstart", (e) => {
          touchStartY = e.touches[0].clientY;
        }, { passive: true });

        controlsElement.addEventListener("touchmove", (e) => {
          touchEndY = e.touches[0].clientY;
          const delta = touchEndY - touchStartY;
          
          if (delta > 0) {
            controlsElement.style.transform = `translateY(${Math.min(delta, 100)}px)`;
            controlsElement.style.transition = "none";
          }
        }, { passive: true });

        controlsElement.addEventListener("touchend", () => {
          const delta = touchEndY - touchStartY;
          
          controlsElement.style.transition = "transform 0.3s ease";
          
          if (delta > 150) {
            closeModal();
          } else {
            controlsElement.style.transform = "translateY(0)";
          }
        }, { passive: true });
      }

      // Close modal on backdrop click
      document.getElementById("modal").addEventListener("click", function (e) {
        const inContent = e.target.closest(".modal-content");
        if (!inContent) closeModal();
      });

      // Error handling
      window.addEventListener("error", (e) => {
        console.error("App error:", e);
        showToast("‚ùå Something went wrong", false);
      });
    </script>
  </body>
</html>