<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Complete your custom PC order with our easy 3-step checkout process.">
    <title>RTS PC Customiser with 3D Preview</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
:root {
    /* New Red & Black Theme Variables */
    --primary-red: #e61919;
    --primary-black: #121212;
    --secondary-black: #1e1e1e;
    --accent-red: #ff3b30;
    --text-light: #f8f8f8;
    --text-gray: #a0a0a0;
    
    /* Adapted from old theme or new additions for compatibility */
    --primary-color: var(--primary-red); /* Main interactive color */
    --primary-hover: #ff4d4d; /* Lighter red for hover */
    --background-dark: var(--primary-black);
    --surface-dark: var(--secondary-black); /* For main panel backgrounds */
    --surface-medium: #2a2a2a; /* Slightly lighter than secondary-black for elements */
    --surface-light: #383838; /* For hover states or subtle borders */
    --text-primary: var(--text-light);
    --text-secondary: var(--text-gray);
    --text-placeholder: #6E6E73; /* Kept from old, adjust if needed */
    --border-color: rgba(255, 255, 255, 0.1); /* New border color */
    --error-color: var(--accent-red);
    --success-color: #34C759; /* Kept green for success, can change to a red theme success if desired */

    --font-main: 'Roboto', sans-serif;
    --font-header: 'Rajdhani', sans-serif;

    --border-radius: 8px; /* General border radius */
    --border-radius-sm: 6px; /* Specific if needed */
    --border-radius-md: 8px; /* Match general */
    --border-radius-lg: 12px; /* Larger radius */
    
    --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); /* General shadow */
    --shadow-sm: 0 2px 8px rgba(0,0,0,0.2);
    --shadow-md: 0 6px 16px rgba(0,0,0,0.25);
    --shadow-lg: 0 12px 32px rgba(0,0,0,0.3);

    --transition: all 0.3s ease;
    --transition-speed: 0.3s; /* For compatibility with old JS if any uses it */
}

body {
    font-family: var(--font-main); /* Uses new --font-main: 'Roboto' */
    margin: 0;
    padding: 0;
    background: var(--primary-black); /* New theme body background */
    color: var(--text-light); /* New theme body text color */
    min-height: 100vh;
    display: flex;
    flex-direction: column; /* Align items for the whole page */
    align-items: center; /* Center content for the whole page */
    padding: 20px; /* Overall page padding */
    overflow-x: hidden;
}

.checkout-container {
    width: 100%;
    max-width: 1400px; 
    background-color: var(--primary-black); /* Main container background, same as body or slightly different */
    border-radius: var(--border-radius-lg); /* Use new theme radius */
    box-shadow: var(--box-shadow); /* Use new theme shadow */
    overflow: hidden; 
    display: flex;
    flex-direction: column;
    height: 85vh; 
    min-height: 650px;
}

.checkout-header {
    padding: 20px 30px; /* Adjusted padding */
    background-color: var(--secondary-black); /* Use theme color for header distinct from main content area */
    border-bottom: 1px solid var(--border-color); /* Uses new --border-color */
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.checkout-header .logo-placeholder { /* This will be the "AFTERSHOCK CHECKOUT" text */
    font-family: var(--font-header); /* Use Rajdhani */
    font-size: 1.8em; /* Keep size or adjust */
    font-weight: 700;
    color: var(--primary-red); /* Themed color */
    letter-spacing: 1px;
}

.progress-indicator {
    display: flex;
    gap: 10px;
}

.progress-indicator .step {
    color: var(--text-secondary);
    font-size: 0.9em;
    padding: 8px 12px;
    border-radius: var(--border-radius-sm);
    background-color: var(--surface-medium);
    border: 1px solid var(--border-color);
    transition: all var(--transition-speed) ease;
    display: flex;
    align-items: center;
    gap: 8px;
}
.progress-indicator .step span {
    background-color: var(--text-placeholder);
    color: var(--surface-dark);
    border-radius: 50%;
    width: 20px;
    height: 20px;
    display: inline-flex;
    justify-content: center;
    align-items: center;
    font-weight: 600;
    font-size: 0.8em;
    transition: all var(--transition-speed) ease;
}

.progress-indicator .step.active {
    color: var(--text-primary);
    background-color: var(--primary-color);
    border-color: var(--primary-color);
    font-weight: 600;
}
.progress-indicator .step.active span {
    background-color: var(--text-primary);
    color: var(--primary-color);
}
.progress-indicator .step.completed {
    color: var(--text-secondary);
    background-color: var(--surface-light);
    border-color: var(--success-color);
}
.progress-indicator .step.completed span {
    background-color: var(--success-color);
    color: var(--text-primary);
}


.checkout-main {
    flex-grow: 1;
    position: relative;
    display: flex;
    padding: 20px; /* Add padding inside main area */
    background-color: var(--surface-dark); /* Background for the main content area */
    border-radius: 0 0 var(--border-radius-lg) var(--border-radius-lg); /* Match container rounding if header is separate */
    overflow: hidden; 
}

.panel-container {
    display: flex;
    width: 100%; 
    height: 100%; 
    /* transition: none; */ 
}

.panel {
    flex-shrink: 0; 
    flex-grow: 0;   
    flex-basis: 120px; /* Minimized width for inactive panels - can adjust */
    height: 100%; 
    padding: 20px; 
    box-sizing: border-box;
    background-color: var(--secondary-black); /* Inactive panel bg from new theme */
    border-radius: var(--border-radius); /* Use new theme radius */
    box-shadow: var(--box-shadow); /* Use new theme shadow */
    margin: 0 5px; 
    
    display: flex;
    flex-direction: column;
    overflow: hidden; 
    cursor: pointer; 
    transition: flex-basis 0.4s ease-in-out, background-color 0.4s ease, box-shadow 0.4s ease;
    position: relative; 
}

.panel.active {
    flex-grow: 1; 
    flex-basis: 75%; /* Active panel takes up most space */
    background-color: var(--primary-black); /* Active panel bg - could be same as body or slightly different */
    box-shadow: 0 8px 30px rgba(230, 25, 25, 0.2); /* More prominent shadow for active, themed */
    cursor: default; 
    margin: 0 10px; /* Slightly more margin for active panel if desired */
}

.panel .panel-header { 
    padding-bottom: 15px;
    border-bottom: 1px solid var(--border-color);
    margin-bottom: 0; 
    transition: margin-bottom 0.4s ease;
    width: 100%; 
    display: flex; /* Added for button alignment */
    justify-content: space-between; /* Added for button alignment */
    align-items: center; /* Added for button alignment */
}
.panel .panel-header > div:first-child { /* Target the title/description block */
    flex-grow: 1;
}
.panel .panel-header h2 { /* Ensure h2 within panel-header uses new theme fonts/colors */
    font-family: var(--font-header);
    color: var(--text-light);
}
.panel .panel-header h2 .step-number {
    color: var(--primary-red);
}
.panel .panel-header p {
    font-family: var(--font-main);
    color: var(--text-gray);
}


.panel.active .panel-header {
    margin-bottom: 20px; 
}

.panel .panel-content-wrapper { /* New wrapper for content and navigation */
    flex-grow: 1;
    overflow: hidden;
    max-height: 0;
    opacity: 0;
    transition: max-height 0.4s ease-in-out, opacity 0.4s ease-in-out 0.1s;
    display: flex;
    flex-direction: column;
}

.panel.active .panel-content-wrapper {
    max-height: 100vh; /* Allow it to take full available height */
    opacity: 1;
}

.panel .panel-content {
    flex-grow: 1;
    /* overflow-y: auto;  Removed to prevent double scrollbars; columns will manage their own overflow */
}

/* Panel 2 will have its content replaced, so specific styles for its old content might not be needed.
   The new Fabric.js customizer will have its own structure and styles.
   We need to ensure the .panel-content area within panel-2 can accommodate it. */
#panel-2.active .panel-content {
    display: flex; 
    flex-direction: column; /* Changed for Fabric customizer layout */
    gap: 0; /* Remove gap if Fabric customizer handles its own spacing */
    height: 100%; /* Ensure it fills the wrapper */
    padding: 0; /* Remove padding if Fabric customizer has its own */
}


.panel .panel-navigation {
    padding-top: 20px; 
    border-top: 1px solid var(--border-color); 
}
/* General button styling from new theme, adapted for checkout buttons */
.next-step-btn, .prev-step-btn, .checkout-button, .select-button {
    padding: 10px 20px; /* Adjusted padding */
    font-family: var(--font-main);
    font-weight: 500;
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: var(--transition);
    border: none;
    text-align: center;
    display: inline-flex; /* For icon alignment */
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.next-step-btn, .select-button {
    background: var(--primary-red);
    color: var(--text-light);
}
.next-step-btn:hover, .select-button:hover {
    background: var(--primary-hover);
    box-shadow: 0 0 10px rgba(230, 25, 25, 0.3);
}
.next-step-btn:disabled, .select-button:disabled { /* Assuming .select-button can be disabled */
    background-color: var(--surface-light) !important; /* Use important if needed to override */
    color: var(--text-placeholder) !important;
    cursor: not-allowed !important;
    box-shadow: none !important;
}

.prev-step-btn {
    background: transparent;
    border: 1px solid var(--primary-red);
    color: var(--primary-red);
}
.prev-step-btn:hover {
    background: rgba(230, 25, 25, 0.1);
    color: var(--primary-hover);
}

.checkout-button { /* This is the final checkout button */
    background-color: var(--success-color); /* Or use a themed red if preferred */
    color: var(--text-light);
    width: 100%;
    padding: 15px 25px;
    font-size: 1.2em;
}
.checkout-button:hover {
    background-color: #28a745; /* Darker green, or themed red hover */
    box-shadow: 0 0 10px rgba(40, 167, 69, 0.3); /* Or themed red shadow */
}

/* Styles for content within panels - general */
.panel-content {
     /* General styling for panel content if needed, but specific panels might override */
}

/* Specific styles for option cards in Panel 1, adapted to new theme */

/* Panel 1: Choose PC */
#panel-1 .panel-content {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 25px;
}

.option-card {
    background-color: var(--secondary-black); /* Use new theme color */
    border-radius: var(--border-radius);
    padding: 20px;
    border: 1px solid var(--border-color);
    transition: var(--transition);
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}
.option-card:hover {
    border-color: var(--primary-color);
    background-color: var(--surface-light); /* Subtle background change on hover */
    box-shadow: var(--shadow-sm); /* Softer shadow */
}
.option-card.selected {
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px var(--primary-color); /* Simpler outline shadow */
    background-color: var(--surface-light);
}

.option-card img {
    width: 100%;
    max-height: 180px;
    object-fit: cover;
    border-radius: var(--border-radius-sm);
    margin-bottom: 15px;
    background-color: var(--background-dark); /* Placeholder bg */
}

.option-card h3 {
    font-size: 1.4em;
    font-weight: 600;
    color: var(--text-primary);
    margin: 0 0 10px 0;
}

.option-card p {
    font-size: 0.95em;
    color: var(--text-secondary);
    margin-bottom: 10px;
    flex-grow: 1;
}
.option-card .price {
    font-size: 1.3em;
    font-weight: 700;
    color: var(--primary-color);
    margin-bottom: 15px;
}

.select-button, .next-step-btn, .prev-step-btn, .checkout-button {
    padding: 12px 25px;
    font-size: 1em;
    font-weight: 600;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    transition: all var(--transition-speed) ease;
    border: none;
    text-align: center;
}

.select-button {
    background-color: var(--primary-color);
    color: var(--text-primary);
    width: 100%;
}
.select-button:hover {
    background-color: var(--primary-hover);
}
.option-card.selected .select-button {
    background-color: var(--success-color);
    /* content: "Selected"; Removed as it's better handled by JS if text needs to change */
}


/* Panel 2: Fabric.js Customizer and 3D Viewer Styles */
#panel-2 .panel-content {
    display: flex;
    flex-direction: row; /* Arrange 2D and 3D side-by-side */
    align-items: flex-start; /* Align items to the top */
    height: 100%;
    /* overflow-y: auto; Removed for better column overflow management */
    gap: 20px; /* Space between 2D customizer and 3D viewer */
}

#panel-2 .customizer-column {
    flex: 1; /* Takes up available space */
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 400px; /* Minimum width for the 2D customizer */
    height: 100%;
}

#panel-2 .viewer-column {
    flex: 1; /* Takes up available space */
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100%;
    min-width: 300px; /* Minimum width for the 3D viewer */
}

#panel-2 .fabric-container {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    max-height: calc(100% - 60px); /* Adjust if there are other elements in the column */
    overflow-y: auto; /* Allows scrolling within the fabric customizer section */
}

#panel-2 #view-tabs {
    display: flex;
    gap: 8px;
    margin-bottom: 15px; /* Keep some space below tabs */
    width: 100%;
    justify-content: center;
    flex-wrap: wrap;
}

#panel-2 .tab { /* Styles for 2D view tabs remain largely the same */
    padding: 8px 15px; /* Smaller padding */
    background: var(--secondary-black);
    color: var(--text-light);
    cursor: pointer;
    border-radius: var(--border-radius);
    font-weight: 500;
    transition: var(--transition);
    border: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    gap: 8px;
}

#panel-2 .tab:hover {
    background: rgba(230, 25, 25, 0.1);
    border-color: var(--primary-red);
}

#panel-2 .tab.active {
    background: var(--primary-red);
    color: var(--text-light);
    border-color: var(--primary-red);
    box-shadow: 0 0 15px rgba(230, 25, 25, 0.4);
}
#panel-2 .tab.view-confirmed { /* New style for confirmed views */
    background: var(--success-color);
    color: var(--text-light);
    border-color: var(--success-color);
}
#panel-2 .tab.view-confirmed:hover {
    background: #28a745; /* Darker green for hover on confirmed */
}


#panel-2 #canvas-container {
    position: relative;
    margin: 0 auto 10px auto; /* Reduced bottom margin */
    width: 100%;
    max-width: 700px; /* Max width for the 2D canvas */
    aspect-ratio: 16 / 12;
    border-radius: var(--border-radius);
    overflow: hidden;
    box-shadow: var(--box-shadow);
    background: var(--secondary-black); 
}

#panel-2 #c { 
    width: 100% !important;
    height: 100% !important; /* Canvas fills container */
    display: block;
    /* background: var(--secondary-black); */ /* Set on container */
}

#panel-2 .controls-section {
    width: 100%;
    max-width: 700px; /* Match 2D canvas area */
    margin-top: 10px; /* Reduced margin */
    background: var(--secondary-black);
    border-radius: var(--border-radius);
    padding: 20px;
    box-shadow: var(--box-shadow);
}

#panel-2 .section-title {
    font-family: var(--font-header);
    font-size: 1.2rem;
    font-weight: 600;
    margin-bottom: 15px;
    color: var(--text-light);
    display: flex;
    align-items: center;
    gap: 8px;
}

#panel-2 #controls { /* Original had this, might not be needed if sections are structured */
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    margin-bottom: 20px;
}

#panel-2 .color-section {
    display: flex;
    flex-direction: column;
    gap: 15px;
    width: 100%;
}

#panel-2 .color-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); /* Adjusted for smaller swatches */
    gap: 10px;
}

#panel-2 .swatch {
    width: 40px; /* Adjusted size */
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    transition: var(--transition);
    position: relative;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

#panel-2 .swatch:hover {
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

#panel-2 .swatch.active {
    border: 3px solid var(--text-light);
}

#panel-2 .swatch.active::after {
    content: '✓';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: var(--text-light); /* Check contrast with swatch bg */
    font-size: 18px; /* Adjusted size */
    text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
}

#panel-2 .upload-section {
    width: 100%;
    margin-top: 20px;
}

#panel-2 .file-upload {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    width: 100%;
}

#panel-2 .upload-area {
    width: 100%;
    padding: 25px; /* Adjusted padding */
    border: 2px dashed var(--border-color); /* Use theme border color */
    border-radius: var(--border-radius);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 15px;
    cursor: pointer;
    transition: var(--transition);
    background: rgba(255, 255, 255, 0.03); /* Subtle background */
}

#panel-2 .upload-area:hover {
    border-color: var(--primary-red);
    background: rgba(230, 25, 25, 0.05);
}

#panel-2 .upload-area i {
    font-size: 36px; /* Adjusted size */
    color: var(--text-gray);
}

#panel-2 .upload-text {
    color: var(--text-gray);
    text-align: center;
}

#panel-2 .fabric-button { /* Renamed to avoid conflict with general .button */
    padding: 10px 20px; /* Adjusted padding */
    background: var(--primary-red);
    color: var(--text-light);
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-weight: 500;
    transition: var(--transition);
    display: inline-flex; /* Changed from flex for inline behavior */
    align-items: center;
    gap: 8px;
    font-size: 15px; /* Adjusted font size */
}

#panel-2 .fabric-button:hover {
    background: var(--primary-hover);
    box-shadow: 0 0 15px rgba(230, 25, 25, 0.4);
}

#panel-2 .fabric-button.secondary {
    background: transparent;
    border: 1px solid var(--primary-red);
    color: var(--primary-red);
}

#panel-2 .fabric-button.secondary:hover {
    background: rgba(230, 25, 25, 0.1);
}

#panel-2 .actions {
    display: flex;
    gap: 15px;
    margin-top: 20px;
    flex-wrap: wrap;
    justify-content: center;
}

#panel-2 .loading { /* Specific to fabric canvas loading */
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 100; /* Ensure it's above canvas but below panel header if needed */
    border-radius: var(--border-radius);
    opacity: 0;
    pointer-events: none;
    transition: var(--transition);
}

#panel-2 .loading.active {
    opacity: 1;
    pointer-events: all;
}

#panel-2 .spinner {
    width: 50px;
    height: 50px;
    border: 5px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: var(--primary-red);
    animation: spin 1s ease-in-out infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}
/* End of Fabric.js Customizer Styles */

/* Cropping Modal Styles */
.crop-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: none; /* Hidden by default */
    justify-content: center;
    align-items: center;
    z-index: 1000; /* Ensure it's above other content */
}
.crop-modal-content {
    background-color: var(--secondary-black);
    padding: 25px;
    border-radius: var(--border-radius-lg);
    box-shadow: var(--shadow-lg);
    width: 90%;
    max-width: 700px;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
    border: 1px solid var(--border-color);
}
.crop-modal-content h3 {
    font-family: var(--font-header);
    color: var(--primary-red);
    text-align: center;
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 1.6em;
}
.crop-modal-preview-container {
    width: 100%;
    min-height: 200px;
    max-height: calc(90vh - 200px); /* Adjust based on other elements */
    border: 2px dashed var(--primary-red);
    background-color: var(--primary-black);
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative; /* For crop mask/outline */
    overflow: hidden; /* Important for containing the image and masks */
    margin-bottom: 20px;
    border-radius: var(--border-radius-sm);
}
.crop-modal-preview-container img {
    max-width: 100%;
    max-height: 100%; /* Ensure image fits within container */
    display: block;
    object-fit: contain;
}
.crop-modal-mask { /* For the modal cropper */
    position: absolute;
    background-color: rgba(0, 0, 0, 0.65);
    pointer-events: none;
}
.crop-modal-window-border { /* For the modal cropper */
    position: absolute;
    box-sizing: border-box;
    border: 2px solid var(--primary-hover);
    pointer-events: none;
}
.crop-modal-dimensions-note {
    text-align: center;
    color: var(--text-gray);
    font-size: 0.9em;
    margin-bottom: 20px;
}
.crop-modal-actions {
    display: flex;
    justify-content: space-around;
    margin-top: 15px;
}
.crop-modal-actions .fabric-button { /* Re-use existing button style */
    min-width: 120px;
}
/* End Cropping Modal Styles */

/* Panel 3: Summary */
.summary-details {
    background-color: var(--surface-medium);
    padding: 25px;
    border-radius: var(--border-radius-md);
    margin-bottom: 30px;
    border: 1px solid var(--border-color);
}
.summary-details h3 {
    font-size: 1.6em;
    color: var(--text-primary);
    margin-top: 0;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--border-color);
}
.summary-details h4 {
    font-size: 1.1em;
    color: var(--primary-color);
    margin-top: 0;
    margin-bottom: 8px;
}
.summary-details p {
    color: var(--text-secondary);
    margin-bottom: 5px;
}
.summary-details p span {
    color: var(--text-primary);
    font-weight: 500;
}
#summaryDesignSelection, #summaryPcSelection {
    margin-bottom: 20px;
}
#summaryDesignImage {
    border-radius: var(--border-radius-sm);
    border: 1px solid var(--border-color);
    background-color: var(--background-dark);
}
.total-price {
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid var(--border-color);
}
.total-price h4 {
    font-size: 1.8em;
    color: var(--text-primary);
    text-align: right;
}
.total-price h4 span {
    color: var(--primary-color);
    font-weight: 700;
}

.checkout-button {
    background-color: var(--success-color);
    color: var(--text-primary);
    width: 100%;
    padding: 15px 25px;
    font-size: 1.2em;
}
.checkout-button:hover {
    background-color: #28a745; /* Darker green */
}

/* Panel Navigation */
.panel-navigation {
    margin-top: 30px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-top: 20px;
    border-top: 1px solid var(--border-color);
}

.next-step-btn {
    background-color: var(--primary-color);
    color: var(--text-primary);
}
.next-step-btn:hover {
    background-color: var(--primary-hover);
}
.next-step-btn:disabled {
    background-color: var(--surface-light);
    color: var(--text-placeholder);
    cursor: not-allowed;
}

.prev-step-btn {
    background-color: transparent;
    color: var(--primary-color);
    border: 2px solid var(--primary-color);
}
.prev-step-btn:hover {
    background-color: var(--primary-color);
    color: var(--text-primary);
}

/* Responsive Adjustments */
#panel-2 #threejs-viewer-container {
    width: 100%;
    height: 400px; /* Default height, can be adjusted */
    min-height: 300px;
    background-color: var(--primary-black); /* Darker background for viewer */
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-sm);
    margin-top: 10px; /* Space above the 3D viewer */
    position: relative; /* For potential overlays or controls */
    overflow: hidden; /* Ensure renderer stays within bounds */
}

#panel-2 .viewer-column .section-title { /* Re-use section title style for 3D viewer header */
    margin-top: 0; /* No top margin if it's the first element */
    margin-bottom: 10px;
}


/* Responsive Adjustments */
@media (max-width: 1024px) { /* Adjust breakpoint for when to stack Panel 2 columns */
    #panel-2 .panel-content {
        flex-direction: column; /* Stack 2D customizer and 3D viewer */
        align-items: center; /* Center them when stacked */
    }
    #panel-2 .customizer-column, #panel-2 .viewer-column {
        width: 100%;
        max-width: 700px; /* Allow them to take full width of the panel content area */
    }
    #panel-2 #threejs-viewer-container {
        height: 350px; /* Adjust height for stacked layout */
    }
}

@media (max-width: 768px) {
    body {
        padding: 0; /* Remove padding for mobile full screen */
        align-items: stretch;
    }
    .checkout-container {
        height: 100vh; /* Full viewport height */
        min-height: 0; /* Remove min-height for mobile */
        border-radius: 0; /* No border radius on mobile */
        box-shadow: none; /* No shadow on mobile */
        margin: 0;
    }
    .checkout-main {
        padding: 10px; /* Smaller padding for mobile */
        border-radius: 0;
    }
    .panel-container {
        flex-direction: column; /* Stack panels vertically */
        width: 100%;
        height: auto; /* Height based on content */
    }
    .panel {
        flex-basis: auto !important; /* Override desktop flex-basis */
        width: 100%;
        height: auto; /* Height based on content */
        margin: 0 0 10px 0; /* Margin between vertical panels */
        cursor: pointer; /* Headers are always clickable */
    }
    .panel.active {
        /* No change in width/flex-grow needed for vertical stack, active just shows content */
    }
    .panel .panel-header {
        /* Styles for header are mostly fine, ensure it's clickable */
    }
    .panel .panel-content-wrapper {
        /* Transitions for max-height and opacity remain */
    }
    .panel.active .panel-content-wrapper {
        max-height: none; /* Allow content to define height, or set a large enough value */
    }
     /* Ensure panel content specific to step 2 still works in vertical layout */
    #panel-2.active .panel-content { /* Already column from 1024px breakpoint, this confirms for smaller */
        flex-direction: column; 
    }
    /* .design-preview-area, .design-controls-area no longer exist with that naming */
    #panel-2 .customizer-column, #panel-2 .viewer-column {
        flex: none; 
        width: 100%; 
    }
    #panel-2 #threejs-viewer-container {
        height: 300px; /* Further adjust height for smaller mobile */
    }

    .checkout-header {
        flex-direction: column;
        gap: 15px;
        padding: 20px;
    }
    .progress-indicator {
        flex-wrap: wrap;
        justify-content: center;
    }
    .progress-indicator .step {
        font-size: 0.8em;
        padding: 6px 10px;
    }
    .progress-indicator .step span {
        width: 18px;
        height: 18px;
        font-size: 0.7em;
    }
    .panel {
        padding: 20px;
        min-height: calc(100vh - 150px); /* Adjust based on header height */
    }
    .panel-header h2 {
        font-size: 1.6em;
    }
    .panel-header p {
        font-size: 0.9em;
    }
    #panel-1 .panel-content {
        grid-template-columns: 1fr; /* Stack cards on mobile */
    }
    .panel-navigation {
        flex-direction: column-reverse; /* Stack buttons */
        gap: 15px;
    }
    .next-step-btn, .prev-step-btn, .checkout-button {
        width: 100%;
    }
}

@media (max-width: 480px) {
    .checkout-header .logo-placeholder {
        font-size: 1.5em;
    }
    .progress-indicator .step {
        font-size: 0.7em; /* Further reduce for very small screens */
        gap: 5px;
    }
    .progress-indicator .step span {
        width: 18px;
        height: 18px;
        font-size: 0.7em;
    }
    .panel-header h2 {
        font-size: 1.4em;
    }
    .panel-header p {
        font-size: 0.9em;
    }
}
    </style>
</head>
<body>
    <div class="checkout-container">
        <header class="checkout-header">
            <div class="logo-placeholder">AFTERSHOCK CHECKOUT</div>
            <div class="progress-indicator">
                <div class="step active" id="step-indicator-1"><span>1</span> Choose PC</div>
                <div class="step" id="step-indicator-2"><span>2</span> Choose Design</div>
                <div class="step" id="step-indicator-3"><span>3</span> Summary & Pay</div>
            </div>
        </header>

        <main class="checkout-main">
            <div class="panel-container">
                <!-- Panel 1: Choose PC -->
                <section id="panel-1" class="panel active" data-panel-index="0">
                    <div class="panel-header">
                        <div> <!-- Wrapper for title and p -->
                            <h2><span class="step-number">Step 1:</span> Choose Your PC</h2>
                            <p>Select the base model or configuration that suits your needs.</p>
                        </div>
                        <div class="panel-navigation" style="border-top: none; padding-top: 0; margin-top: 0;"> <!-- Moved Next button here -->
                            <button class="next-step-btn" data-target-panel-index="1" disabled>Next: Choose Design</button>
                        </div>
                    </div>
                    <div class="panel-content-wrapper">
                        <div class="panel-content">
                            <!-- PC Options will go here -->
                            <div class="option-card">
                                <img src="https://cdn.shopify.com/s/files/1/0522/3320/7988/files/RTS-SR-LVL-7-5070-V1_-_Copy_2.png?v=1747799855" alt="EOFY ZEAL MINI : LVL 7">
                                <h3>EOFY ZEAL MINI : LVL 7</h3>
                                <p>Balanced performance for everyday gaming and productivity.</p>
                                <p class="price">$1,499 AUD</p>
                                <button class="select-button" data-pc-name="EOFY ZEAL MINI : LVL 7" data-pc-price="1499">Select This PC</button>
                            </div>
                            <div class="option-card">
                                <img src="https://cdn.shopify.com/s/files/1/0522/3320/7988/files/ZMKOIPOND_f4aeac9a-c709-48e1-91ed-e98fac12c63c.jpg?v=1747187487" alt="KOI POND">
                                <h3>KOI POND</h3>
                                <p>High-end components for serious 1440p/4K gaming.</p>
                                <p class="price">$2,499 AUD</p>
                                <button class="select-button" data-pc-name="KOI POND" data-pc-price="2499">Select This PC</button>
                            </div>
                            <div class="option-card">
                                <img src="https://cdn.shopify.com/s/files/1/0522/3320/7988/files/ZEALMINIBLUEKOI_SR_45833da9-4b60-463f-b5af-7dbd24e13622.jpg?v=1747187458" alt="BLUE KOI">
                                <h3>BLUE KOI</h3>
                                <p>Top-tier power for demanding creative workloads.</p>
                                <p class="price">$3,999 AUD</p>
                                <button class="select-button" data-pc-name="BLUE KOI" data-pc-price="3999">Select This PC</button>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Panel 2: Choose Design -->
                <section id="panel-2" class="panel" data-panel-index="1">
                    <div class="panel-header">
                        <h2><span class="step-number">Step 2:</span> Choose Your Design</h2>
                        <p>Personalize your PC with custom artwork or select from our gallery.</p>
                    </div>
                    <div class="panel-content-wrapper">
                        <div class="panel-content"> <!-- This will now contain two columns -->
                            <div class="customizer-column">
                                <div id="view-tabs">
                                    <div class="tab active" data-viewkey="front"><i class="fas fa-desktop"></i> Front</div>
                                    <div class="tab" data-viewkey="top"><i class="fas fa-arrow-up"></i> Top</div>
                                    <div class="tab" data-viewkey="side1"><i class="fas fa-columns"></i> Side 1</div>
                                    <div class="tab" data-viewkey="side2"><i class="fas fa-columns fa-flip-horizontal"></i> Side 2</div>
                                </div>
                                <div class="fabric-container">
                                    <div id="canvas-container">
                                      <canvas id="c"></canvas>
                                      <div class="loading" id="loadingIndicator"><div class="spinner"></div></div>
                                    </div>
                                    <div class="controls-section">
                                      <div class="color-section">
                                        <div class="section-title"><i class="fas fa-paint-roller"></i> Chassis Color</div>
                                        <div class="color-grid" id="chassisColors">
                                          <div class="swatch chassis-color-swatch active" style="background:#3B82F6;" data-chassis-color="blue" title="Blue Chassis"></div>
                                          <div class="swatch chassis-color-swatch" style="background:#10B981;" data-chassis-color="green" title="Green Chassis"></div>
                                          <div class="swatch chassis-color-swatch" style="background:#EC4899;" data-chassis-color="pink" title="Pink Chassis"></div>
                                          <div class="swatch chassis-color-swatch" style="background:#8B5CF6;" data-chassis-color="purple" title="Purple Chassis"></div>
                                        </div>
                                      </div>
                                      <div class="upload-section">
                                        <div class="section-title"><i class="fas fa-upload"></i> Custom Design for Current View</div>
                                        <div class="file-upload">
                                          <div class="upload-area" id="uploadArea">
                                            <i class="fas fa-cloud-upload-alt"></i>
                                            <div class="upload-text"><strong>Click to upload</strong> or drag & drop</div>
                                          </div>
                                          <input type="file" id="fileInput" style="display: none;" accept="image/*">
                                        </div>
                                      </div>
                                      <div class="actions">
                                        <button class="fabric-button" id="resetBtn"><i class="fas fa-undo"></i> Reset View</button>
                                        <button class="fabric-button" id="deleteBtn"><i class="fas fa-trash"></i> Remove Design</button>
                                        <button class="fabric-button" id="downloadBtn"><i class="fas fa-download"></i> Save Design</button>
                                      </div>
                                    </div>
                                </div>
                            </div>
                            <div class="viewer-column">
                                <div class="section-title"><i class="fas fa-cube"></i> 3D Preview</div>
                                <div id="threejs-viewer-container">
                                    <!-- 3D Viewer will be initialized here by Three.js -->
                                </div>
                                <!-- Add any 3D specific controls here if needed -->
                            </div>
                        </div>
                        <div class="panel-navigation">
                            <button class="prev-step-btn" data-target-panel-index="0">Back: Choose PC</button>
                            <button class="next-step-btn" data-target-panel-index="2">Next: Summary</button>
                        </div>
                    </div>
                </section>

                <!-- Panel 3: Summary + Checkout -->
                <section id="panel-3" class="panel" data-panel-index="2">
                    <div class="panel-header">
                        <h2><span class="step-number">Step 3:</span> Summary & Checkout</h2>
                        <p>Review your selections and proceed to payment.</p>
                    </div>
                    <div class="panel-content-wrapper">
                        <div class="panel-content">
                            <div class="summary-details">
                                <h3>Order Summary</h3>
                                <div id="summaryPcSelection">
                                    <h4>Selected PC:</h4>
                                    <p>Name: <span id="summaryPcName">N/A</span></p>
                                    <p>Price: $<span id="summaryPcPrice">0.00</span> AUD</p>
                                </div>
                                <div id="summaryDesignSelection">
                                    <h4>Selected Design:</h4>
                                    <p>Name: <span id="summaryDesignName">N/A</span></p>
                                    <img id="summaryDesignImage" src="#" alt="Selected Design Preview" style="max-width: 200px; max-height: 150px; margin-top: 10px; display: none;">
                                </div>
                                <hr>
                                <div class="total-price">
                                    <h4>Total: $<span id="summaryTotalPrice">0.00</span> AUD</h4>
                                </div>
                            </div>
                            <button class="checkout-button">Proceed to Checkout</button>
                        </div>
                        <div class="panel-navigation">
                            <button class="prev-step-btn" data-target-panel-index="1">Back: Choose Design</button>
                        </div>
                    </div>
                </section>
            </div>
        </main>
    </div>
    <script>
    (function () {
        const panelContainer = document.querySelector('.panel-container');
        const panels = Array.from(document.querySelectorAll('.panel'));
        const nextButtons = document.querySelectorAll('.next-step-btn');
        const prevButtons = document.querySelectorAll('.prev-step-btn');
        const progressSteps = document.querySelectorAll('.progress-indicator .step');

        const pcSelectionButtons = document.querySelectorAll('#panel-1 .select-button');
        
        // Removed obsolete variables from previous Panel 2 implementation
        // const artworkUploadInput = document.getElementById('artworkUpload');
        // const artworkPreview = document.getElementById('artworkPreview'); 
        // const artworkPreviewText = document.getElementById('artworkPreviewText'); 
        // const artworkOnPcPreview = document.getElementById('artworkOnPcPreview'); 
        // const pcPreviewPlaceholderText = document.getElementById('pcPreviewPlaceholderText'); 
        // const galleryItems = document.querySelectorAll('#panel-2 .gallery-item'); // Not in HTML

        const summaryPcName = document.getElementById('summaryPcName');
        const summaryPcPrice = document.getElementById('summaryPcPrice');
        const summaryDesignName = document.getElementById('summaryDesignName');
        const summaryDesignImage = document.getElementById('summaryDesignImage');
        const summaryTotalPrice = document.getElementById('summaryTotalPrice');

        const checkoutButton = document.querySelector('.checkout-button');

        let currentPanelIndex = 0; 
        // Updated orderDetails structure to support multiple custom designs per view
        let orderDetails = {
            pc: null, 
            customDesigns: {} // Stores designs for each view: { front: { name, image }, top: { name, image }, ... }
        };

        function setActivePanel(targetIndex) {
            if (targetIndex < 0 || targetIndex >= panels.length) return;

            // Validation for stepping forward
            if (targetIndex > currentPanelIndex) {
                if (currentPanelIndex === 0 && !orderDetails.pc) {
                    alert("Please select a PC configuration to continue.");
                    return;
                }
                // Panel 2 (Design) validation: Allowing to proceed without custom design.
                // The summary will reflect 'No Custom Design'.
            }
            
            currentPanelIndex = targetIndex;

            panels.forEach((panel, index) => {
                if (index === currentPanelIndex) {
                    panel.classList.add('active');
                } else {
                    panel.classList.remove('active');
                }
            });

            progressSteps.forEach((step, index) => {
                step.classList.remove('active', 'completed');
                if (index < currentPanelIndex) {
                    step.classList.add('completed');
                } else if (index === currentPanelIndex) {
                    step.classList.add('active');
                }
            });

            if (currentPanelIndex === panels.length - 1) { // If on the summary panel
                updateSummary();
            }
        }

        function updateSummary() {
            let total = 0;
            if (orderDetails.pc) {
                summaryPcName.textContent = orderDetails.pc.name;
                summaryPcPrice.textContent = parseFloat(orderDetails.pc.price).toFixed(2);
                total += parseFloat(orderDetails.pc.price);
            } else {
                summaryPcName.textContent = 'N/A';
                summaryPcPrice.textContent = '0.00';
            }

            let hasCustomDesign = false;
            let firstCustomDesignImage = null;
            let designNames = [];

            for (const viewKey in orderDetails.customDesigns) {
                if (orderDetails.customDesigns[viewKey] && orderDetails.customDesigns[viewKey].image) {
                    hasCustomDesign = true;
                    designNames.push(orderDetails.customDesigns[viewKey].name);
                    if (!firstCustomDesignImage) {
                        firstCustomDesignImage = orderDetails.customDesigns[viewKey].image;
                    }
                }
            }

            if (hasCustomDesign) {
                summaryDesignName.textContent = `Custom Design(s): ${designNames.join(', ')}`;
                if (firstCustomDesignImage) {
                    summaryDesignImage.src = firstCustomDesignImage;
                    summaryDesignImage.style.display = 'block';
                } else {
                    summaryDesignImage.style.display = 'none';
                }
            } else {
                summaryDesignName.textContent = 'No Custom Design (Included)';
                summaryDesignImage.style.display = 'none';
            }
            summaryTotalPrice.textContent = total.toFixed(2);
        }

        // Panel 1: PC Selection
        const optionCards = document.querySelectorAll('#panel-1 .option-card');
        optionCards.forEach(card => {
            card.addEventListener('click', () => {
                // Find the button within this card and click it
                const button = card.querySelector('.select-button');
                if (button) {
                    button.click(); // This will trigger the existing button's event listener
                }
            });
        });

        pcSelectionButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent card click from re-triggering if button is clicked directly
                pcSelectionButtons.forEach(btn => btn.closest('.option-card').classList.remove('selected'));
                button.closest('.option-card').classList.add('selected');
                orderDetails.pc = {
                    name: button.dataset.pcName,
                    price: parseFloat(button.dataset.pcPrice)
                };
                // Ensure the next button is correctly targeted even after moving it to the header of panel-1
                const panel1NextBtn = document.querySelector('#panel-1 .panel-header .next-step-btn');
                if (panel1NextBtn) {
                    panel1NextBtn.disabled = false;
                    console.log("Panel 1 Next button enabled.");
                }
                updateSummary();
                console.log("orderDetails.pc after selection:", orderDetails.pc);
            });
        });
        
        // Navigation Buttons
        nextButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetIndex = parseInt(button.dataset.targetPanelIndex);
                console.log(`Next button clicked. Target panel index: ${targetIndex}`);

                // Explicitly check orderDetails.pc for the Panel 1 next button
                if (currentPanelIndex === 0 && targetIndex === 1 && !orderDetails.pc) {
                    alert("Please select a PC configuration to continue (from button click).");
                    console.log("Panel 1 Next button: PC not selected.");
                    return;
                }
                setActivePanel(targetIndex);
            });
        });

        prevButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetIndex = parseInt(button.dataset.targetPanelIndex);
                setActivePanel(targetIndex);
            });
        });

        // Click on minimized panel headers to activate them
        panels.forEach((panel, index) => {
            const header = panel.querySelector('.panel-header');
            if (header) {
                header.addEventListener('click', () => {
                    if (!panel.classList.contains('active')) {
                        setActivePanel(index);
                    }
                });
            }
        });
        
        // Click on progress steps to navigate
        progressSteps.forEach((stepIndicator, index) => {
            stepIndicator.addEventListener('click', () => {
                 // Allow navigation to any step via progress bar if it's already completed or current
                if (index <= currentPanelIndex || panels[index].classList.contains('completed-step-via-progress')) {
                     setActivePanel(index);
                } else {
                    // Check if requirements for previous steps are met before jumping
                    let canProceed = true;
                    for (let i = 0; i < index; i++) {
                        if (i === 0 && !orderDetails.pc) {
                            alert("Please select a PC configuration first (Step 1).");
                            canProceed = false;
                            setActivePanel(0); // Go to step 1
                            break;
                        }
                        // Panel 2 no longer has strict validation for proceeding, as 'No Custom Design' is default.
                        // If it's step 2, no specific validation is needed before jumping.
                    }
                    if (canProceed) {
                        setActivePanel(index);
                    }
                }
            });
        });


        if (checkoutButton) {
            checkoutButton.addEventListener('click', () => {
                if (!orderDetails.pc) {
                    alert("Please complete PC selection (Step 1).");
                    setActivePanel(0);
                    return;
                }
                
                let orderSummaryText = `Checkout initiated!\nPC: ${orderDetails.pc.name} ($${orderDetails.pc.price})\n`;
                let hasCustomDesign = Object.values(orderDetails.customDesigns).some(design => design !== null);
                if (hasCustomDesign) {
                    orderSummaryText += "Custom Designs:\n";
                    for (const viewKey in orderDetails.customDesigns) {
                        if (orderDetails.customDesigns[viewKey]) {
                            orderSummaryText += `- ${orderDetails.customDesigns[viewKey].name}\n`;
                        }
                    }
                } else {
                    orderSummaryText += "Design: No Custom Design\n";
                }
                orderSummaryText += `Total: $${summaryTotalPrice.textContent} AUD`;

                alert(orderSummaryText);
                console.log("Order Details:", orderDetails);
            });
        }

        // Initial setup calls
        setActivePanel(0); // Start with the first panel active
        
        // --- FABRIC.JS CUSTOMIZER SCRIPT START ---
        // Adapted from user-provided HTML for Panel 2

        const fabricCanvasContainer = document.querySelector('#panel-2 #canvas-container');
        let fabricCanvas;
        let currentFabricView = 'front';
        let fabricPanelRect;
        const fabricLoadingIndicator = document.querySelector('#panel-2 #loadingIndicator');
        let currentChassisColor = 'blue'; // Default chassis color
        let originalUploadedFile = null;

        // Cropping Modal Elements
        const cropModalOverlay = document.getElementById('cropModalOverlay');
        const cropModalImageToCrop = document.getElementById('cropModalImageToCrop');
        const cropModalPreviewContainer = document.getElementById('cropModalPreviewContainer');
        const cropModalDimensionsNote = document.getElementById('cropModalDimensionsNote');
        const confirmCropBtn = document.getElementById('confirmCropBtn');
        const cancelCropBtn = document.getElementById('cancelCropBtn');
        let currentCropDataForModal = {}; // To store crop selection from modal

        // Define base path and image names for dynamic loading
        const chassisBasePath = ''; // Corrected: Paths are now relative to current dir (Zeal Pastel)
        const chassisImageFiles = {
            blue: { front: 'front_2000px.png', top: 'top_2000px.png', side1: 'hero_2000 px.png', side2: 'rear_2000px.png', back: 'back_2000px.png' },
            green: { front: 'front_2000px.png', top: 'top_2000px.png', side1: 'hero_2000 px.png', side2: 'rear_2000px.png', back: 'back_2000px.png' },
            pink: { front: 'front_2000px.png', top: 'top_2000px.png', side1: 'hero_2000 px.png', side2: 'rear_2000px (1).png', back: 'back_2000px.png' }, // Note: Pink has rear_2000px (1).png
            purple: { front: 'Purple Zeal M-Front.png', top: 'Purple Zeal M-Top.png', side1: 'Purple Zeal M-Side.png', side2: 'Purple Zeal M-Rear.png', back: 'Purple Zeal M-Back.png' }
        };
        
        // Fabric views define the 2D customization areas and map to 3D model faces
        const fabricViews = {
            front: { panel: { left: 250, top: 200, width: 300, height: 200 }, targetWidth: 785.20, targetHeight: 992.13, designs: {}, threeJSFaceIndex: 4 }, // Front face (+Z)
            top: { panel: { left: 300, top: 100, width: 200, height: 150 }, targetWidth: 490.39, targetHeight: 1057.32, designs: {}, threeJSFaceIndex: 2 }, // Top face (+Y)
            side1: { panel: { left: 200, top: 150, width: 350, height: 250 }, targetWidth: 1167.87, targetHeight: 983.62, designs: {}, threeJSFaceIndex: 0 }, // Right face (+X)
            side2: { panel: { left: 200, top: 150, width: 350, height: 250 }, targetWidth: 1173.54, targetHeight: 986.46, designs: {}, threeJSFaceIndex: 1 }, // Left face (-X)
            back: { designs: {}, threeJSFaceIndex: 5 } // Back face (-Z), not directly customizable in 2D but part of 3D model
        };
        
        // --- THREE.JS 3D PREVIEWER SCRIPT START ---
        let threeScene, threeCamera, threeRenderer, threeCube, threeControls;
        const threeJsContainer = document.getElementById('threejs-viewer-container');
        const defaultFaceImage = '../Assets/hero.png'; // Corrected: Path relative to Testing/Zeal Pastel/index.html

        function initThreeJs() {
            if (!threeJsContainer || threeScene) return; // Already initialized or container not found

            threeScene = new THREE.Scene();
            threeScene.background = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--primary-black').trim());

            const aspect = threeJsContainer.clientWidth / threeJsContainer.clientHeight;
            threeCamera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            threeCamera.position.set(2, 2, 3); // Adjusted camera position
            threeCamera.lookAt(0, 0, 0);

            threeRenderer = new THREE.WebGLRenderer({ antialias: true });
            threeRenderer.setSize(threeJsContainer.clientWidth, threeJsContainer.clientHeight);
            threeJsContainer.appendChild(threeRenderer.domElement);

            // Basic cube geometry (adjust dimensions as needed for a PC case shape)
            const geometry = new THREE.BoxGeometry(2, 2.5, 1); // width, height, depth
            
            // Create an array of materials. Each face can have a different material/texture.
            // Order: +X, -X, +Y, -Y, +Z, -Z (Right, Left, Top, Bottom, Front, Back)
            const materials = [];
            const loader = new THREE.TextureLoader();
            loader.setCrossOrigin('anonymous'); // Important for external images if any

            const initialChassisImages = chassisImageFiles[currentChassisColor];
            const faceOrderForThreeJS = [ // Mapping fabricViews/chassisImageFiles keys to Three.js face order
                initialChassisImages.side1,  // +X (Right)
                initialChassisImages.side2,  // -X (Left) - Assuming side2 is the other main side
                initialChassisImages.top,    // +Y (Top)
                defaultFaceImage,            // -Y (Bottom) - Using default for now
                initialChassisImages.front,  // +Z (Front)
                initialChassisImages.back    // -Z (Back)
            ];

            faceOrderForThreeJS.forEach(imgPath => {
                let fullTexturePath;
                if (imgPath === defaultFaceImage) { // Check if it's the default placeholder image
                    fullTexturePath = imgPath; // Use the path directly (e.g., '../Assets/hero.png')
                } else {
                    // For chassis-specific images, prepend base path and color folder
                    fullTexturePath = chassisBasePath + currentChassisColor + '/' + imgPath; 
                }
                const texture = loader.load(
                    fullTexturePath, 
                    () => threeRenderer.render(threeScene, threeCamera), // onLoad
                    undefined, // onProgress
                    (err) => console.error(`Error loading initial texture: ${fullTexturePath}`, err) // onError
                );
                texture.colorSpace = THREE.SRGBColorSpace; // Correct colorspace for textures
                materials.push(new THREE.MeshStandardMaterial({ map: texture, roughness: 0.7, metalness: 0.3 }));
            });
            
            threeCube = new THREE.Mesh(geometry, materials);
            threeScene.add(threeCube);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            threeScene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            threeScene.add(directionalLight);

            animateThreeJs();
            window.addEventListener('resize', onThreeJsWindowResize, false);
        }

        function onThreeJsWindowResize() {
            if (!threeCamera || !threeRenderer || !threeJsContainer) return;
            threeCamera.aspect = threeJsContainer.clientWidth / threeJsContainer.clientHeight;
            threeCamera.updateProjectionMatrix();
            threeRenderer.setSize(threeJsContainer.clientWidth, threeJsContainer.clientHeight);
            threeRenderer.render(threeScene, threeCamera);
        }

        function animateThreeJs() {
            if (!threeScene) return; // Stop if scene not initialized
            requestAnimationFrame(animateThreeJs);
            // if (threeControls) threeControls.update(); // If using OrbitControls
            if (threeCube) {
                 // Simple rotation for demonstration if no controls
                 // threeCube.rotation.x += 0.005;
                 // threeCube.rotation.y += 0.005;
            }
            threeRenderer.render(threeScene, threeCamera);
        }
        
        function updateThreeJSModelTexture(viewKey, imageDataUrl) {
            if (!threeCube || !fabricViews[viewKey] || typeof fabricViews[viewKey].threeJSFaceIndex === 'undefined') return;

            const faceIndex = fabricViews[viewKey].threeJSFaceIndex;
            const loader = new THREE.TextureLoader();
            loader.setCrossOrigin('anonymous');
            
            loader.load(
                imageDataUrl, 
                (newTexture) => {
                    newTexture.colorSpace = THREE.SRGBColorSpace;
                    if (threeCube.material[faceIndex]) {
                        threeCube.material[faceIndex].map = newTexture;
                        threeCube.material[faceIndex].needsUpdate = true;
                        threeRenderer.render(threeScene, threeCamera);
                        console.log(`Texture updated for 3D model face: ${viewKey} (index ${faceIndex})`);
                    }
                },
                undefined, // onProgress
                (err) => console.error(`Error loading texture for 3D model update (${viewKey}): ${imageDataUrl}`, err) // onError
            );
        }
        
        function updateThreeJSChassisColor(newColor) {
            if (!threeCube || !chassisImageFiles[newColor]) return;
            const newChassisImages = chassisImageFiles[newColor];
            const loader = new THREE.TextureLoader();
            loader.setCrossOrigin('anonymous');

            const faceOrderMap = { // Map viewKey to the image file for that view
                side1: newChassisImages.side1,
                side2: newChassisImages.side2,
                top: newChassisImages.top,
                front: newChassisImages.front,
                back: newChassisImages.back
            };
            
            threeCube.material.forEach((material, index) => {
                let viewKeyForFace;
                // Determine which viewKey corresponds to this face index
                for (const vk in fabricViews) {
                    if (fabricViews[vk].threeJSFaceIndex === index) {
                        viewKeyForFace = vk;
                        break;
                    }
                }

                if (viewKeyForFace && faceOrderMap[viewKeyForFace]) {
                    const imgPath = chassisBasePath + newColor + '/' + faceOrderMap[viewKeyForFace];
                    // Check if there's a custom design for this view and color
                    const designStorageKey = newColor + "_" + viewKeyForFace;
                    const customDesignData = fabricViews[viewKeyForFace].designs[designStorageKey];

                    // Priority: custom design > base chassis image
                    if (orderDetails.customDesigns[viewKeyForFace] && orderDetails.customDesigns[viewKeyForFace].image) {
                        loader.load(
                            orderDetails.customDesigns[viewKeyForFace].image, 
                            (texture) => {
                                texture.colorSpace = THREE.SRGBColorSpace;
                                material.map = texture;
                                material.needsUpdate = true;
                            },
                            undefined,
                            (err) => console.error(`Error loading custom design texture for ${viewKeyForFace}: ${orderDetails.customDesigns[viewKeyForFace].image}`, err)
                        );
                    } else {
                        // Load base chassis image
                        loader.load(
                            imgPath, 
                            (texture) => {
                                texture.colorSpace = THREE.SRGBColorSpace;
                                material.map = texture;
                                material.needsUpdate = true;
                            },
                            undefined,
                            (err) => console.error(`Error loading base chassis texture for ${viewKeyForFace}: ${imgPath}`, err)
                        );
                    }
                } else if (index === 3) { // Bottom face, use defaultFaceImage
                     loader.load(
                        defaultFaceImage, 
                        (texture) => { 
                            texture.colorSpace = THREE.SRGBColorSpace;
                            material.map = texture;
                            material.needsUpdate = true;
                        },
                        undefined,
                        (err) => console.error(`Error loading default bottom texture: ${defaultFaceImage}`, err)
                    );
                }
            });
            setTimeout(() => threeRenderer.render(threeScene, threeCamera), 100); // Render after a short delay
        }


        // --- END THREE.JS 3D PREVIEWER SCRIPT ---

        function showFabricLoading() {
            if (fabricLoadingIndicator) fabricLoadingIndicator.classList.add('active');
        }
        function hideFabricLoading() {
            if (fabricLoadingIndicator) fabricLoadingIndicator.classList.remove('active');
        }

        function showFabricNotification(message, type = 'info') { // Added type for potential styling
            console.log(`Notification (${type}): ${message}`); // Log to console instead
        }

        function resizeFabricCanvas() {
            if (!fabricCanvas || !fabricCanvasContainer) return;
            const containerWidth = fabricCanvasContainer.clientWidth;
            // Maintain aspect ratio from CSS (16:12 or 4:3.5)
            const aspectRatio = 16 / 12; // Or parse from css aspect-ratio if more dynamic
            const containerHeight = containerWidth / aspectRatio; 
            
            fabricCanvas.setWidth(containerWidth);
            fabricCanvas.setHeight(containerHeight);
            fabricCanvas.calcOffset(); // Recalculate canvas offset after resizing
            fabricCanvas.renderAll();
            
            if (currentFabricView) {
                loadFabricView(currentFabricView, false); // Reload to adjust objects
            }
        }

        function loadFabricView(viewKey, animate = true) {
            if (!fabricCanvas) return;
            showFabricLoading();
            const viewConfig = fabricViews[viewKey]; // Contains panel overlay info
            currentFabricView = viewKey; // front, side, top

            const chassisImageSet = chassisImageFiles[currentChassisColor];
            if (!chassisImageSet) {
                console.error("Chassis color not found:", currentChassisColor);
                hideFabricLoading();
                return;
            }
            const bgImageUrl = chassisBasePath + currentChassisColor + '/' + chassisImageSet[viewKey];
            
            fabricCanvas.clear(); // Clear previous objects
            
            fabric.Image.fromURL(
                bgImageUrl, 
                function(img) { // onLoad callback
                    // --- Force re-read of container dimensions ---
                    let canvasWidth = fabricCanvasContainer.clientWidth;
                const aspectRatio = 16 / 12; 
                let canvasHeight = canvasWidth / aspectRatio;
                if (canvasWidth === 0) {
                    console.warn("2D Canvas container width is 0, attempting fallback.");
                    canvasWidth = fabricCanvas.getElement().style.width ? parseInt(fabricCanvas.getElement().style.width, 10) : 600; // Default or last known
                    canvasHeight = canvasWidth / aspectRatio;
                }
                fabricCanvas.setWidth(canvasWidth);
                fabricCanvas.setHeight(canvasHeight);
                fabricCanvas.calcOffset();
                // --- End of re-read ---
                
                // Scale background image to fit and center (contain behavior)
                // This time, we want to ensure the entire image is visible (object-fit: contain behavior)
                // and then we will center it.
                const imgAspectRatio = img.width / img.height;
                const canvasAspectRatio = canvasWidth / canvasHeight;
                let scaleFactor;

                if (imgAspectRatio > canvasAspectRatio) {
                    // Image is wider than canvas, scale to fit width
                    scaleFactor = canvasWidth / img.width;
                } else {
                    // Image is taller than canvas, scale to fit height
                    scaleFactor = canvasHeight / img.height;
                }
                
                const scaledWidth = img.width * scaleFactor;
                const scaledHeight = img.height * scaleFactor;

                img.set({
                    scaleX: scaleFactor,
                    scaleY: scaleFactor,
                    left: (canvasWidth - scaledWidth) / 2, // Center horizontally
                    top: (canvasHeight - scaledHeight) / 2, // Center vertically
                    originX: 'left', // Origin is top-left for easier calculations
                    originY: 'top',
                    selectable: false,
                    evented: false
                });
                fabricCanvas.setBackgroundImage(img, fabricCanvas.renderAll.bind(fabricCanvas));
                
                // The designable panel coordinates are relative to the original image dimensions.
                // We need to scale and offset them based on the background image's scaled size and position.
                const panelLeftOnImage = viewConfig.panel.left;
                const panelTopOnImage = viewConfig.panel.top;
                const panelWidthOnImage = viewConfig.panel.width;
                const panelHeightOnImage = viewConfig.panel.height;

                fabricPanelRect = new fabric.Rect({
                    left: img.left + (panelLeftOnImage * scaleFactor),
                    top: img.top + (panelTopOnImage * scaleFactor),
                    width: panelWidthOnImage * scaleFactor,
                    height: panelHeightOnImage * scaleFactor,
                    fill: 'rgba(0,0,0,0.0)', // Transparent, but helps in debugging if set to a color
                    selectable: false, 
                    evented: false,
                    opacity: 1, // Keep it visible for design placement
                    absolutePositioned: true // This might not be strictly necessary if coords are canvas-relative
                });
                fabricCanvas.add(fabricPanelRect);
                // fabricPanelRect.set('fill', 'rgba(255,0,0,0.3)'); // For debugging panel position

                // Load stored user designs for this view (from orderDetails.customDesigns)
                const storedDesign = orderDetails.customDesigns[viewKey];
                if (storedDesign && storedDesign.image) {
                    fabric.Image.fromURL(storedDesign.image, function(designImg) {
                        // Re-calculate position and scale based on current fabricPanelRect
                        const designRectCenterX = fabricPanelRect.left + fabricPanelRect.width / 2;
                        const designRectCenterY = fabricPanelRect.top + fabricPanelRect.height / 2;
                        const maxDesignWidth = fabricPanelRect.width * 0.95;
                        const maxDesignHeight = fabricPanelRect.height * 0.95;
                        let designScaleFactor = Math.min(maxDesignWidth / designImg.width, maxDesignHeight / designImg.height);
                        designScaleFactor = Math.max(designScaleFactor, 0.01);

                        designImg.set({
                            left: designRectCenterX, // Position relative to current panelRect
                            top: designRectCenterY,
                            originX: 'center',
                            originY: 'center',
                            scaleX: designScaleFactor, // Scale relative to current panelRect
                            scaleY: designScaleFactor,
                            angle: storedDesign.angle || 0, // Use saved angle or default
                            cornerColor: 'var(--primary-red)', cornerStyle: 'circle', transparentCorners: false,
                            borderColor: 'var(--primary-red)', cornerSize: 10,
                            opacity: animate ? 0 : 1,
                            isCustomDesign: true, // Mark as custom design
                            absolutePositioned: true
                        });
                        fabricCanvas.add(designImg);
                        if (animate) {
                            setTimeout(() => {
                                designImg.animate('opacity', 1, { duration: 300, onChange: fabricCanvas.renderAll.bind(fabricCanvas) });
                            }, 300);
                        }
                    }, { crossOrigin: 'anonymous' });

                    // Mark tab as confirmed if a design is present
                    const activeTabElement = Array.from(document.querySelectorAll('#panel-2 .tab')).find(t => t.dataset.viewkey === viewKey);
                    if (activeTabElement) activeTabElement.classList.add('view-confirmed');

                } else {
                    // If no custom design, remove 'view-confirmed' class
                    const activeTabElement = Array.from(document.querySelectorAll('#panel-2 .tab')).find(t => t.dataset.viewkey === viewKey);
                    if (activeTabElement) activeTabElement.classList.remove('view-confirmed');
                }
                
                hideFabricLoading();
                fabricCanvas.requestRenderAll(); // Use requestRenderAll for potentially better timing
            }, 
            { // options object for fromURL
                crossOrigin: 'anonymous' 
            },
            // Note: Fabric's Image.fromURL doesn't have a direct third error callback argument like THREE.TextureLoader.
            // Errors here would typically be network errors caught by browser or if the image format is unsupported by Fabric.
            // We can wrap this in a try-catch or rely on browser console for such errors.
            // For simplicity, not adding explicit error handling here as path issues are more common with TextureLoader.
            );
        }
        
        function changeChassisColor(newColor) {
            if (currentChassisColor === newColor) return;
            currentChassisColor = newColor;
            
            // Update 2D Fabric view
            loadFabricView(currentFabricView, true); 
            document.querySelectorAll('#panel-2 #chassisColors .chassis-color-swatch').forEach(swatch => {
                 swatch.classList.toggle('active', swatch.dataset.chassisColor === newColor);
            });

            // Update 3D model chassis color/textures
            if (threeScene) {
                updateThreeJSChassisColor(newColor);
            }
        }

        function switchFabricView(viewKey) {
            if (currentFabricView === viewKey || !fabricCanvas) return;
            
            // Save current 2D design objects to be reloaded later if needed (though now using orderDetails.customDesigns)
            // This part is mainly for internal Fabric.js state if multiple objects were allowed.
            // For single object design, orderDetails.customDesigns is the primary source.
            
            // Update active tab for 2D view
            document.querySelectorAll('#panel-2 .tab').forEach(tab => tab.classList.remove('active'));
            const activeTab = Array.from(document.querySelectorAll('#panel-2 .tab')).find(t => t.dataset.viewkey === viewKey);
            if(activeTab) activeTab.classList.add('active');
            
            // Animate out existing 2D objects
            let objectsToAnimate = fabricCanvas.getObjects().filter(obj => obj !== fabricCanvas.backgroundImage);
            if (objectsToAnimate.length > 0) {
                objectsToAnimate.forEach(obj => {
                    obj.animate('opacity', 0, { 
                        duration: 200, 
                        onChange: fabricCanvas.renderAll.bind(fabricCanvas),
                        onComplete: () => {
                            // Check if this is the last object to fade out
                            objectsToAnimate = objectsToAnimate.filter(o => o !== obj);
                            if(objectsToAnimate.length === 0) {
                                loadFabricView(viewKey, true); // Load new view after all faded
                            }
                        }
                    });
                });
            } else {
                loadFabricView(viewKey, true);
            }
        }

        function handleFabricFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            originalUploadedFile = file; // Store the original file
            const currentViewConfig = fabricViews[currentFabricView];
            if (!currentViewConfig || !currentViewConfig.targetWidth || !currentViewConfig.targetHeight) {
                showFabricNotification("Error: Target dimensions for the current view are not defined.", "error");
                return;
            }

            // Show cropping modal
            showCropModal(file, currentViewConfig.targetWidth, currentViewConfig.targetHeight);
        }

        // This function will be called AFTER cropping is confirmed
        function applyCroppedImageToFabric(croppedImageDataURL) {
            if (!fabricCanvas || !fabricPanelRect || !croppedImageDataURL) {
                hideFabricLoading(); // Ensure loading is hidden if something goes wrong
                return;
            }
            showFabricLoading(); // Show loading while Fabric processes the image
            
            // Clear any previous custom designs for this view before adding new one
            fabricCanvas.getObjects().forEach(obj => {
                if (obj.isCustomDesign) {
                    fabricCanvas.remove(obj);
                }
            });
            fabricCanvas.requestRenderAll();

            fabric.Image.fromURL(croppedImageDataURL, function(img) {
                // Scale and position the uploaded (and now pre-cropped) design relative to the fabricPanelRect
                    // The image is already cropped to the target aspect ratio.
                    // Now, scale it to fit within the fabricPanelRect for display on the PC model.
                    const panelRectAspectRatio = fabricPanelRect.width / fabricPanelRect.height;
                    const croppedImageAspectRatio = img.width / img.height; // Should match target aspect ratio

                    let displayScaleFactor;
                    if (croppedImageAspectRatio > panelRectAspectRatio) {
                        // Cropped image is wider than panel rect, scale to fit width
                        displayScaleFactor = (fabricPanelRect.width * 0.95) / img.width;
                    } else {
                        // Cropped image is taller or same aspect ratio, scale to fit height
                        displayScaleFactor = (fabricPanelRect.height * 0.95) / img.height;
                    }
                    displayScaleFactor = Math.max(displayScaleFactor, 0.01);

                    img.set({
                        left: fabricPanelRect.left + fabricPanelRect.width / 2,
                        top: fabricPanelRect.top + fabricPanelRect.height / 2,
                        originX: 'center',
                        originY: 'center',
                        scaleX: displayScaleFactor,
                        scaleY: displayScaleFactor,
                        cornerColor: 'var(--primary-red)', cornerStyle: 'circle', transparentCorners: false,
                        borderColor: 'var(--primary-red)', cornerSize: 10,
                        opacity: 1,
                        isCustomDesign: true,
                        absolutePositioned: true
                    });
                    fabricCanvas.add(img);
                    fabricCanvas.setActiveObject(img);

                    const activeViewTab = document.querySelector(`#panel-2 .tab[data-viewkey="${currentFabricView}"]`);
                    if (activeViewTab) activeViewTab.classList.add('view-confirmed');
                    
                    // Update orderDetails with the cropped image data URL for the current view
                    if (originalUploadedFile) {
                         orderDetails.customDesigns[currentFabricView] = {
                            name: `Custom (${currentFabricView}): ${originalUploadedFile.name}`,
                            image: croppedImageDataURL 
                        };
                    }
                    updateSummary(); 

                    // Update 3D model texture for the current view
                    if (threeScene) {
                        updateThreeJSModelTexture(currentFabricView, croppedImageDataURL);
                    }

                    fabricCanvas.requestRenderAll();
                    hideFabricLoading();
                }, { crossOrigin: 'anonymous' });
        }

        function resetFabricView() {
            if(!fabricCanvas) return;
            // Clear custom design objects from canvas
            fabricCanvas.getObjects().forEach(obj => {
                if (obj.isCustomDesign) {
                    fabricCanvas.remove(obj);
                }
            });
            
            // Clear stored design for this view in orderDetails
            orderDetails.customDesigns[currentFabricView] = null;
            updateSummary(); // Update summary after design is cleared

            // Reload background to refresh 2D view
            loadFabricView(currentFabricView); 
            
            // Reset corresponding 3D model face to base chassis texture
            if (threeScene && fabricViews[currentFabricView] && typeof fabricViews[currentFabricView].threeJSFaceIndex !== 'undefined') {
                const faceIndex = fabricViews[currentFabricView].threeJSFaceIndex;
                const baseChassisImageSet = chassisImageFiles[currentChassisColor];
                let baseImageForFace = defaultFaceImage; // Fallback
                if (baseChassisImageSet && baseChassisImageSet[currentFabricView]) {
                    baseImageForFace = chassisBasePath + currentChassisColor + '/' + baseChassisImageSet[currentFabricView];
                } else if (currentFabricView === 'back' && baseChassisImageSet && baseChassisImageSet.back) { // Explicit back handling for 2D canvas background
                    baseImageForFace = chassisBasePath + currentChassisColor + '/' + baseChassisImageSet.back;
                }
                // If baseImageForFace is still defaultFaceImage, it means it's a view not directly mapped (like bottom) or an issue.
                // For 3D model reset, we need to ensure the correct base texture is re-applied.

                const loader = new THREE.TextureLoader();
                loader.setCrossOrigin('anonymous');
                loader.load(
                    baseImageForFace, 
                    (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        if (threeCube.material[faceIndex]) {
                            threeCube.material[faceIndex].map = texture;
                            threeCube.material[faceIndex].needsUpdate = true;
                            threeRenderer.render(threeScene, threeCamera);
                        }
                    },
                    undefined,
                    (err) => console.error(`Error loading texture for 3D reset (${currentFabricView}): ${baseImageForFace}`, err)
                );
            }
            showFabricNotification('View reset successfully!');
        }

        function deleteSelectedFabricDesign() {
            if(!fabricCanvas) return;
            const activeObject = fabricCanvas.getActiveObject();
            if (activeObject && activeObject !== fabricPanelRect && activeObject.isCustomDesign) {
                activeObject.animate('opacity', 0, {
                    duration: 200, onChange: fabricCanvas.renderAll.bind(fabricCanvas),
                    onComplete: function() { 
                        fabricCanvas.remove(activeObject); 
                        orderDetails.customDesigns[currentFabricView] = null; // Clear from order details
                        updateSummary(); // Update summary
                        // Remove confirmed class from tab
                        const activeTabElement = document.querySelector(`#panel-2 .tab[data-viewkey="${currentFabricView}"]`);
                        if (activeTabElement) activeTabElement.classList.remove('view-confirmed');
                        showFabricNotification('Design removed successfully!'); 
                        // Reset 3D model texture to chassis default
                        resetFabricView(); // This will also update 3D model face
                    }
                });
            } else {
                showFabricNotification('Please select a design to remove.');
            }
        }

        function saveFabricDesign() {
            if(!fabricCanvas) return;
            fabricCanvas.discardActiveObject().renderAll();
            const dataURL = fabricCanvas.toDataURL({ format: 'png', quality: 1 });
            const link = document.createElement('a');
            link.download = `pc-design-${currentFabricView}-view.png`;
            link.href = dataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showFabricNotification('Design saved successfully!');
        }
        
        function initializeFabricCanvas() {
            if (fabricCanvas || !document.getElementById('panel-2').classList.contains('active')) return; // Already initialized or panel not active

            fabricCanvas = new fabric.Canvas('c', { preserveObjectStacking: true }); // Allow selection
            resizeFabricCanvas(); // Initial resize
            loadFabricView(currentFabricView, false); // Load default view without animation first time

            let currentlyEditedObject = null;

            fabricCanvas.on('selection:created', function(opt) {
                if (currentlyEditedObject && currentlyEditedObject.isCustomDesign) {
                    currentlyEditedObject.set('opacity', 1);
                }
                if (opt.selected && opt.selected.length === 1 && opt.selected[0].isCustomDesign) {
                    currentlyEditedObject = opt.selected[0];
                    currentlyEditedObject.set('opacity', 0.7);
                } else {
                    currentlyEditedObject = null; 
                }
                fabricCanvas.requestRenderAll();
            });

            fabricCanvas.on('selection:updated', function(opt) {
                if (currentlyEditedObject && currentlyEditedObject.isCustomDesign && (!opt.selected || opt.selected.length === 0 || currentlyEditedObject !== opt.selected[0])) {
                     currentlyEditedObject.set('opacity', 1);
                }
                if (opt.selected && opt.selected.length === 1 && opt.selected[0].isCustomDesign) {
                    currentlyEditedObject = opt.selected[0];
                    currentlyEditedObject.set('opacity', 0.7);
                } else {
                    if(currentlyEditedObject && currentlyEditedObject.isCustomDesign) currentlyEditedObject.set('opacity', 1);
                    currentlyEditedObject = null;
                }
                fabricCanvas.requestRenderAll();
            });

            fabricCanvas.on('selection:cleared', function(opt) {
                if (opt.deselected) {
                    opt.deselected.forEach(obj => {
                        if (obj.isCustomDesign) {
                            obj.set('opacity', 1);
                        }
                    });
                } else if (currentlyEditedObject && currentlyEditedObject.isCustomDesign) { 
                    currentlyEditedObject.set('opacity', 1);
                }
                currentlyEditedObject = null;
                fabricCanvas.requestRenderAll();
            });


            // Event listeners for Fabric customizer (scoped to Panel 2)
            document.querySelectorAll('#panel-2 .tab').forEach(tab => {
                tab.addEventListener('click', function() { 
                    const viewKey = this.dataset.viewkey;
                    if (fabricViews.hasOwnProperty(viewKey)) {
                       switchFabricView(viewKey);
                    }
                });
            });
            // Chassis Color Swatches
            document.querySelectorAll('#panel-2 #chassisColors .chassis-color-swatch').forEach(swatch => {
                swatch.addEventListener('click', function() { 
                    changeChassisColor(this.dataset.chassisColor); 
                    // Visually update active chassis swatch
                    document.querySelectorAll('#panel-2 #chassisColors .chassis-color-swatch').forEach(s => s.classList.remove('active'));
                    this.classList.add('active');
                });
            });

            const fabricFileInput = document.querySelector('#panel-2 #fileInput');
            if(fabricFileInput) fabricFileInput.addEventListener('change', handleFabricFileUpload);
            
            const fabricUploadArea = document.querySelector('#panel-2 #uploadArea');
            if(fabricUploadArea) {
                fabricUploadArea.addEventListener('click', function() { if(fabricFileInput) fabricFileInput.click(); });
                fabricUploadArea.addEventListener('dragover', function(e) { e.preventDefault(); this.style.borderColor = 'var(--primary-red)'; this.style.background = 'rgba(230, 25, 25, 0.05)'; });
                fabricUploadArea.addEventListener('dragleave', function(e) { e.preventDefault(); this.style.borderColor = 'var(--border-color)'; this.style.background = 'rgba(255, 255, 255, 0.03)'; });
                fabricUploadArea.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.style.borderColor = 'var(--border-color)'; this.style.background = 'rgba(255, 255, 255, 0.03)';
                    if (e.dataTransfer.files.length && fabricFileInput) {
                        fabricFileInput.files = e.dataTransfer.files;
                        handleFabricFileUpload({ target: { files: e.dataTransfer.files } });
                    }
                });
            }
            const fabricResetBtn = document.querySelector('#panel-2 #resetBtn');
            if(fabricResetBtn) fabricResetBtn.addEventListener('click', resetFabricView);
            const fabricDeleteBtn = document.querySelector('#panel-2 #deleteBtn');
            if(fabricDeleteBtn) fabricDeleteBtn.addEventListener('click', deleteSelectedFabricDesign);
            const fabricDownloadBtn = document.querySelector('#panel-2 #downloadBtn');
            if(fabricDownloadBtn) fabricDownloadBtn.addEventListener('click', saveFabricDesign);
            
            window.addEventListener('resize', resizeFabricCanvas); // Fabric canvas resize
        }
        
        // Modify setActivePanel to initialize Fabric when Panel 2 becomes active
        const originalSetActivePanel = setActivePanel;
        setActivePanel = function(targetIndex) {
            originalSetActivePanel(targetIndex); // Call original function
            if (targetIndex === 1 && panels[1].classList.contains('active')) {
                setTimeout(() => {
                    initializeFabricCanvas();
                    initThreeJs(); // Initialize Three.js when panel 2 is active
                    onThreeJsWindowResize(); // Ensure 3D canvas is sized correctly
                }, 50);
            } else if (targetIndex !== 1) {
                // Optional: Cleanup Three.js scene if navigating away from panel 2 to free resources
                // if (threeScene) {
                //     if (threeRenderer) threeJsContainer.removeChild(threeRenderer.domElement);
                //     threeScene = null; threeCamera = null; threeRenderer = null; threeCube = null;
                //     window.removeEventListener('resize', onThreeJsWindowResize, false);
                // }
                if (cropModalOverlay && cropModalOverlay.style.display === 'flex') {
                    hideCropModal();
                }
            }
        }

    // --- Cropping Modal Logic (mostly unchanged, ensure it calls applyCroppedImageToFabric) ---
    function showCropModal(file, targetWidth, targetHeight) {
        const reader = new FileReader();
        reader.onload = function(e) {
            cropModalImageToCrop.src = e.target.result;
            cropModalImageToCrop.style.display = 'block'; // Make sure it's visible
            cropModalDimensionsNote.textContent = `Target: ${Math.round(targetWidth)} x ${Math.round(targetHeight)} px (for ${currentFabricView} view)`;
            
            cropModalImageToCrop.onload = () => { // Ensure image is loaded in modal before initializing cropper UI
                initializeModalCropperUI(cropModalImageToCrop, cropModalPreviewContainer, targetWidth, targetHeight);
            };
            if (cropModalImageToCrop.complete) { // If already loaded (e.g. from cache)
                initializeModalCropperUI(cropModalImageToCrop, cropModalPreviewContainer, targetWidth, targetHeight);
            }
            cropModalOverlay.style.display = 'flex';
        }
        reader.readAsDataURL(file);
    }

    function hideCropModal() {
        cropModalOverlay.style.display = 'none';
        cropModalImageToCrop.src = '#'; // Clear image
        clearModalCropperUI(cropModalPreviewContainer);
        currentCropDataForModal = {}; // Reset crop data
        if(document.querySelector('#panel-2 #fileInput')) { // Reset file input in main panel
            document.querySelector('#panel-2 #fileInput').value = '';
        }
    }

    function initializeModalCropperUI(imageElement, containerElement, targetWidth, targetHeight) {
        clearModalCropperUI(containerElement);
        
        const imgDisplayWidth = imageElement.offsetWidth;
        const imgDisplayHeight = imageElement.offsetHeight;

        const targetAspectRatio = targetWidth / targetHeight;
        let cropWindowDisplayWidth, cropWindowDisplayHeight;

        if (imgDisplayWidth / imgDisplayHeight > targetAspectRatio) {
            cropWindowDisplayHeight = imgDisplayHeight;
            cropWindowDisplayWidth = cropWindowDisplayHeight * targetAspectRatio;
        } else {
            cropWindowDisplayWidth = imgDisplayWidth;
            cropWindowDisplayHeight = cropWindowDisplayWidth / targetAspectRatio;
        }

        const cropWindowDisplayLeft = (imgDisplayWidth - cropWindowDisplayWidth) / 2;
        const cropWindowDisplayTop = (imgDisplayHeight - cropWindowDisplayHeight) / 2;
        
        // Correctly calculate image offset within its parent (cropModalPreviewContainer)
        // This is crucial if the image is not perfectly centered or positioned within its parent.
        const imageRect = imageElement.getBoundingClientRect();
        const containerRect = containerElement.getBoundingClientRect();

        const imgOffsetX = imageRect.left - containerRect.left;
        const imgOffsetY = imageRect.top - containerRect.top;


        const masks = {
            top: document.createElement('div'), bottom: document.createElement('div'),
            left: document.createElement('div'), right: document.createElement('div')
        };
        for (const key in masks) {
            masks[key].className = 'crop-modal-mask'; // Use modal specific class
            masks[key].classList.add(`modal-cropper-mask-element`); // For easy removal
            containerElement.appendChild(masks[key]);
        }
        masks.top.style.cssText = `top:${imgOffsetY}px; left:${imgOffsetX}px; width:${imgDisplayWidth}px; height:${cropWindowDisplayTop}px;`;
        masks.bottom.style.cssText = `top:${imgOffsetY + cropWindowDisplayTop + cropWindowDisplayHeight}px; left:${imgOffsetX}px; width:${imgDisplayWidth}px; height:${imgDisplayHeight - (cropWindowDisplayTop + cropWindowDisplayHeight)}px;`;
        masks.left.style.cssText = `top:${imgOffsetY + cropWindowDisplayTop}px; left:${imgOffsetX}px; width:${cropWindowDisplayLeft}px; height:${cropWindowDisplayHeight}px;`;
        masks.right.style.cssText = `top:${imgOffsetY + cropWindowDisplayTop}px; left:${imgOffsetX + cropWindowDisplayLeft + cropWindowDisplayWidth}px; width:${imgDisplayWidth - (cropWindowDisplayLeft + cropWindowDisplayWidth)}px; height:${cropWindowDisplayHeight}px;`;

        const cropWindowBorder = document.createElement('div');
        cropWindowBorder.className = 'crop-modal-window-border'; // Use modal specific class
        cropWindowBorder.classList.add(`modal-cropper-mask-element`);
        cropWindowBorder.style.cssText = `top:${imgOffsetY + cropWindowDisplayTop}px; left:${imgOffsetX + cropWindowDisplayLeft}px; width:${cropWindowDisplayWidth}px; height:${cropWindowDisplayHeight}px;`;
        containerElement.appendChild(cropWindowBorder);

        // Store the crop selection relative to the *displayed* image in the modal
        // This will be converted to original image coordinates when confirming crop
        currentCropDataForModal = {
            displayX: cropWindowDisplayLeft,
            displayY: cropWindowDisplayTop,
            displayWidth: cropWindowDisplayWidth,
            displayHeight: cropWindowDisplayHeight,
            imgDisplayWidth: imgDisplayWidth,
            imgDisplayHeight: imgDisplayHeight,
            targetWidth: targetWidth, // Store target for final canvas
            targetHeight: targetHeight
        };
    }

    function clearModalCropperUI(containerElement) {
        const elementsToRemove = containerElement.querySelectorAll(`.modal-cropper-mask-element`);
        elementsToRemove.forEach(el => el.remove());
    }

    confirmCropBtn.addEventListener('click', async () => {
        if (!cropModalImageToCrop.src || cropModalImageToCrop.src.endsWith('#') || !originalUploadedFile) {
            showFabricNotification("No image loaded in cropper.", "error");
            return;
        }
        if (!currentCropDataForModal.targetWidth) {
            showFabricNotification("Crop data is incomplete.", "error");
            return;
        }

        const originalImg = new Image();
        originalImg.src = cropModalImageToCrop.src; // This is the dataURL of the uploaded image

        originalImg.onload = async () => {
            const scaleX = originalImg.naturalWidth / currentCropDataForModal.imgDisplayWidth;
            const scaleY = originalImg.naturalHeight / currentCropDataForModal.imgDisplayHeight;

            const sourceX = currentCropDataForModal.displayX * scaleX;
            const sourceY = currentCropDataForModal.displayY * scaleY;
            const sourceWidth = currentCropDataForModal.displayWidth * scaleX;
            const sourceHeight = currentCropDataForModal.displayHeight * scaleY;

            const canvas = document.createElement('canvas');
            canvas.width = Math.round(currentCropDataForModal.targetWidth);
            canvas.height = Math.round(currentCropDataForModal.targetHeight);
            const ctx = canvas.getContext('2d');

            try {
                ctx.drawImage(
                    originalImg,
                    sourceX, sourceY, sourceWidth, sourceHeight,
                    0, 0, canvas.width, canvas.height
                );
                const croppedImageDataURL = canvas.toDataURL('image/png');
                hideCropModal();
                applyCroppedImageToFabric(croppedImageDataURL); // Pass to Fabric.js logic
            } catch (error) {
                console.error("Error cropping image:", error);
                showFabricNotification("Error during cropping. Please try again.", "error");
                hideCropModal();
            }
        };
        originalImg.onerror = () => {
            showFabricNotification("Error loading image for cropping.", "error");
            hideCropModal();
        };
    });

    cancelCropBtn.addEventListener('click', hideCropModal);
    // --- End Cropping Modal Logic ---

    // --- FABRIC.JS CUSTOMIZER SCRIPT END ---
    
    // Initial summary update on page load (Panel 3 is not active yet)
    // No default design selection needed now that Fabric.js handles designs per view.
    updateSummary(); 
    })(); 
    </script>

    <!-- Cropping Modal HTML -->
    <div id="cropModalOverlay" class="crop-modal-overlay">
        <div class="crop-modal-content">
            <h3>Crop Your Design</h3>
            <p id="cropModalDimensionsNote" class="crop-modal-dimensions-note">Target dimensions: N/A</p>
            <div id="cropModalPreviewContainer" class="crop-modal-preview-container">
                <img id="cropModalImageToCrop" src="#" alt="Image to crop">
                <!-- Masks and border will be added here by JS -->
            </div>
            <div class="crop-modal-actions">
                <button id="confirmCropBtn" class="fabric-button"><i class="fas fa-check"></i> Confirm Crop</button>
                <button id="cancelCropBtn" class="fabric-button secondary"><i class="fas fa-times"></i> Cancel</button>
            </div>
        </div>
    </div>
</body>
</html>
